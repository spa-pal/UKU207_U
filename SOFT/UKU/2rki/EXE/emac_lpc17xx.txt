; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\EXE\emac_lpc17xx.o --depend=.\EXE\emac_lpc17xx.d --feedback=.\EXE\UKU_220_IPS_TERMOKOMPENSAT.fed --cpu=Cortex-M3 --apcs=interwork -O1 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\NXP\LPC17xx -D__MICROLIB -DUKU_220_IPS_TERMOKOMPENSAT -DUKU2071x --omf_browse=.\EXE\emac_lpc17xx.crf C:\Keil\ARM\Boards\Keil\MCB1700\RL\TCPnet\Library\EMAC_LPC17xx.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tx_descr_init PROC
;;;324    
;;;325    static void tx_descr_init (void) {
000000  b530              PUSH     {r4,r5,lr}
;;;326      /* Initialize Transmit Descriptor and Status array. */
;;;327      U32 i;
;;;328    
;;;329      for (i = 0; i < NUM_TX_FRAG; i++) {
000002  2000              MOVS     r0,#0
;;;330        Tx_Desc[i].Packet = (U32)&tx_buf[i];
000004  4cff              LDR      r4,|L1.1028|
000006  2200              MOVS     r2,#0                 ;329
000008  49ff              LDR      r1,|L1.1032|
;;;331        Tx_Desc[i].Ctrl   = 0;
;;;332        Tx_Stat[i].Info   = 0;
00000a  f1010318          ADD      r3,r1,#0x18
                  |L1.14|
00000e  eb000540          ADD      r5,r0,r0,LSL #1       ;330
000012  eb042545          ADD      r5,r4,r5,LSL #9       ;330
000016  f8415030          STR      r5,[r1,r0,LSL #3]     ;330
00001a  eb0105c0          ADD      r5,r1,r0,LSL #3       ;331
00001e  606a              STR      r2,[r5,#4]            ;331
000020  f8432020          STR      r2,[r3,r0,LSL #2]
000024  1c40              ADDS     r0,r0,#1              ;329
000026  2803              CMP      r0,#3                 ;329
000028  d3f1              BCC      |L1.14|
;;;333      }
;;;334    
;;;335      /* Set EMAC Transmit Descriptor Registers. */
;;;336      LPC_EMAC->TxDescriptor       = (U32)&Tx_Desc[0];
00002a  48f8              LDR      r0,|L1.1036|
00002c  6001              STR      r1,[r0,#0]
;;;337      LPC_EMAC->TxStatus           = (U32)&Tx_Stat[0];
00002e  6043              STR      r3,[r0,#4]
;;;338      LPC_EMAC->TxDescriptorNumber = NUM_TX_FRAG-1;
000030  f04f0102          MOV      r1,#2
000034  6081              STR      r1,[r0,#8]
;;;339    
;;;340      /* Tx Descriptors Point to 0 */
;;;341      LPC_EMAC->TxProduceIndex  = 0;
000036  60c2              STR      r2,[r0,#0xc]
;;;342    }
000038  bd30              POP      {r4,r5,pc}
;;;343    
                          ENDP

                  rx_descr_init PROC
;;;301    
;;;302    static void rx_descr_init (void) {
00003a  b570              PUSH     {r4-r6,lr}
;;;303      /* Initialize Receive Descriptor and Status array. */
;;;304      U32 i;
;;;305    
;;;306      for (i = 0; i < NUM_RX_FRAG; i++) {
00003c  2000              MOVS     r0,#0
;;;307        Rx_Desc[i].Packet  = (U32)&rx_buf[i];
00003e  4cf2              LDR      r4,|L1.1032|
000040  2300              MOVS     r3,#0                 ;306
000042  3424              ADDS     r4,r4,#0x24
000044  f1a40164          SUB      r1,r4,#0x64
;;;308        Rx_Desc[i].Ctrl    = RCTRL_INT | (ETH_FRAG_SIZE-1);
000048  4df1              LDR      r5,|L1.1040|
;;;309        Rx_Stat[i].Info    = 0;
00004a  f1010220          ADD      r2,r1,#0x20
                  |L1.78|
00004e  eb000640          ADD      r6,r0,r0,LSL #1       ;307
000052  eb042646          ADD      r6,r4,r6,LSL #9       ;307
000056  f8416030          STR      r6,[r1,r0,LSL #3]     ;307
00005a  eb0106c0          ADD      r6,r1,r0,LSL #3       ;308
00005e  6075              STR      r5,[r6,#4]            ;308
000060  f8423030          STR      r3,[r2,r0,LSL #3]
;;;310        Rx_Stat[i].HashCRC = 0;
000064  eb0206c0          ADD      r6,r2,r0,LSL #3
000068  6073              STR      r3,[r6,#4]
00006a  1c40              ADDS     r0,r0,#1              ;306
00006c  2804              CMP      r0,#4                 ;306
00006e  d3ee              BCC      |L1.78|
;;;311      }
;;;312    
;;;313      /* Set EMAC Receive Descriptor Registers. */
;;;314      LPC_EMAC->RxDescriptor       = (U32)&Rx_Desc[0];
000070  48e8              LDR      r0,|L1.1044|
000072  6001              STR      r1,[r0,#0]
;;;315      LPC_EMAC->RxStatus           = (U32)&Rx_Stat[0];
000074  6042              STR      r2,[r0,#4]
;;;316      LPC_EMAC->RxDescriptorNumber = NUM_RX_FRAG-1;
000076  f04f0103          MOV      r1,#3
00007a  6081              STR      r1,[r0,#8]
;;;317    
;;;318      /* Rx Descriptors Point to 0 */
;;;319      LPC_EMAC->RxConsumeIndex  = 0;
00007c  6103              STR      r3,[r0,#0x10]
;;;320    }
00007e  bd70              POP      {r4-r6,pc}
;;;321    
                          ENDP

                  turnaround_MDIO PROC
;;;367    
;;;368    static void turnaround_MDIO (void) {
000080  48e5              LDR      r0,|L1.1048|
;;;369      /* Turnaround MDO is tristated. */
;;;370    
;;;371      LPC_GPIO2->FIODIR &= ~MDIO;
000082  6c01              LDR      r1,[r0,#0x40]
000084  f4217100          BIC      r1,r1,#0x200
000088  6401              STR      r1,[r0,#0x40]
;;;372      LPC_GPIO2->FIOSET  = MDC;
00008a  1541              ASRS     r1,r0,#21
00008c  6581              STR      r1,[r0,#0x58]
;;;373      delay ();
00008e  bf00              NOP      
000090  bf00              NOP      
000092  bf00              NOP      
;;;374      LPC_GPIO2->FIOCLR  = MDC;
000094  65c1              STR      r1,[r0,#0x5c]
;;;375      delay ();
000096  bf00              NOP      
000098  bf00              NOP      
00009a  bf00              NOP      
;;;376    }
00009c  4770              BX       lr
;;;377    
                          ENDP

                  input_MDIO PROC
;;;379    
;;;380    static U32 input_MDIO (void) {
00009e  b510              PUSH     {r4,lr}
;;;381      /* Input a value from the MII PHY management interface. */
;;;382      U32 i,val = 0;
0000a0  2000              MOVS     r0,#0
;;;383    
;;;384      for (i = 0; i < 16; i++) {
0000a2  2100              MOVS     r1,#0
;;;385        val <<= 1;
;;;386        LPC_GPIO2->FIOSET = MDC;
0000a4  4adc              LDR      r2,|L1.1048|
0000a6  f44f7380          MOV      r3,#0x100
                  |L1.170|
0000aa  0040              LSLS     r0,r0,#1              ;385
0000ac  6593              STR      r3,[r2,#0x58]
;;;387        delay ();
0000ae  bf00              NOP      
0000b0  bf00              NOP      
0000b2  bf00              NOP      
;;;388        LPC_GPIO2->FIOCLR = MDC;
0000b4  65d3              STR      r3,[r2,#0x5c]
;;;389        if (LPC_GPIO2->FIOPIN & MDIO) {
0000b6  6d54              LDR      r4,[r2,#0x54]
0000b8  05a4              LSLS     r4,r4,#22
0000ba  d501              BPL      |L1.192|
;;;390          val |= 1;
0000bc  f0400001          ORR      r0,r0,#1
                  |L1.192|
0000c0  1c49              ADDS     r1,r1,#1              ;384
0000c2  2910              CMP      r1,#0x10              ;384
0000c4  d3f1              BCC      |L1.170|
;;;391        }
;;;392      }
;;;393      return (val);
;;;394    }
0000c6  bd10              POP      {r4,pc}
;;;395    
                          ENDP

                  output_MDIO PROC
;;;348    
;;;349    static void output_MDIO (U32 val, U32 n) {
0000c8  b510              PUSH     {r4,lr}
;;;350      /* Output a value to the MII PHY management interface. */
;;;351    
;;;352      for (val <<= (32 - n); n; val <<= 1, n--) {
0000ca  f1c10220          RSB      r2,r1,#0x20
0000ce  4090              LSLS     r0,r0,r2
;;;353        if (val & 0x80000000) {
;;;354          LPC_GPIO2->FIOSET = MDIO;
0000d0  4ad1              LDR      r2,|L1.1048|
0000d2  f44f7400          MOV      r4,#0x200
;;;355        }
;;;356        else {
;;;357          LPC_GPIO2->FIOCLR = MDIO;
;;;358        }
;;;359        delay ();
;;;360        LPC_GPIO2->FIOSET = MDC;
0000d6  1553              ASRS     r3,r2,#21
0000d8  e00e              B        |L1.248|
                  |L1.218|
0000da  2800              CMP      r0,#0                 ;353
0000dc  da01              BGE      |L1.226|
0000de  6594              STR      r4,[r2,#0x58]         ;354
0000e0  e000              B        |L1.228|
                  |L1.226|
0000e2  65d4              STR      r4,[r2,#0x5c]         ;357
                  |L1.228|
0000e4  bf00              NOP                            ;359
0000e6  bf00              NOP                            ;359
0000e8  bf00              NOP                            ;359
0000ea  6593              STR      r3,[r2,#0x58]
;;;361        delay ();
0000ec  bf00              NOP      
0000ee  bf00              NOP      
0000f0  bf00              NOP      
;;;362        LPC_GPIO2->FIOCLR = MDC;
0000f2  65d3              STR      r3,[r2,#0x5c]
0000f4  0040              LSLS     r0,r0,#1              ;352
0000f6  1e49              SUBS     r1,r1,#1              ;352
                  |L1.248|
0000f8  2900              CMP      r1,#0                 ;352
0000fa  d1ee              BNE      |L1.218|
;;;363      }
;;;364    }
0000fc  bd10              POP      {r4,pc}
;;;365    
                          ENDP

                  read_PHY PROC
;;;445    
;;;446    static U16 read_PHY (U32 PhyReg) {
0000fe  b510              PUSH     {r4,lr}
000100  4604              MOV      r4,r0
;;;447      /* Read a PHY register 'PhyReg'. */
;;;448      U32 tout, val;
;;;449    
;;;450      if (dev_175x == __TRUE) {
000102  48c6              LDR      r0,|L1.1052|
000104  7800              LDRB     r0,[r0,#0]  ; dev_175x
000106  2801              CMP      r0,#1
000108  d11d              BNE      |L1.326|
;;;451        /* Software MII Management for LPC175x. */
;;;452        /* Remapped MDC on P2.8 and MDIO on P2.9 does not work. */
;;;453        LPC_GPIO2->FIODIR |= MDIO;
00010a  48c3              LDR      r0,|L1.1048|
00010c  6c01              LDR      r1,[r0,#0x40]
00010e  f4417100          ORR      r1,r1,#0x200
000112  6401              STR      r1,[r0,#0x40]
;;;454    
;;;455        /* 32 consecutive ones on MDO to establish sync */
;;;456        output_MDIO (0xFFFFFFFF, 32);
000114  2120              MOVS     r1,#0x20
000116  f04f30ff          MOV      r0,#0xffffffff
00011a  f7fffffe          BL       output_MDIO
;;;457    
;;;458        /* start code (01), read command (10) */
;;;459        output_MDIO (0x06, 4);
00011e  2104              MOVS     r1,#4
000120  2006              MOVS     r0,#6
000122  f7fffffe          BL       output_MDIO
;;;460    
;;;461        /* write PHY address */
;;;462        output_MDIO (DP83848C_DEF_ADR >> 8, 5);
000126  2105              MOVS     r1,#5
000128  2001              MOVS     r0,#1
00012a  f7fffffe          BL       output_MDIO
;;;463    
;;;464        /* write the PHY register to write */
;;;465        output_MDIO (PhyReg, 5);
00012e  2105              MOVS     r1,#5
000130  4620              MOV      r0,r4
000132  f7fffffe          BL       output_MDIO
;;;466    
;;;467        /* turnaround MDO is tristated */
;;;468        turnaround_MDIO ();
000136  f7fffffe          BL       turnaround_MDIO
;;;469    
;;;470        /* read the data value */
;;;471        val = input_MDIO ();
00013a  f7fffffe          BL       input_MDIO
00013e  4604              MOV      r4,r0
;;;472    
;;;473        /* turnaround MDIO is tristated */
;;;474        turnaround_MDIO ();
000140  f7fffffe          BL       turnaround_MDIO
000144  e011              B        |L1.362|
                  |L1.326|
;;;475      }
;;;476      else {
;;;477        LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
000146  f4447080          ORR      r0,r4,#0x100
00014a  f04f41a0          MOV      r1,#0x50000000
00014e  6288              STR      r0,[r1,#0x28]
;;;478        LPC_EMAC->MCMD = MCMD_READ;
000150  2001              MOVS     r0,#1
000152  6248              STR      r0,[r1,#0x24]
;;;479    
;;;480        /* Wait until operation completed */
;;;481        for (tout = 0; tout < MII_RD_TOUT; tout++) {
000154  2000              MOVS     r0,#0
000156  130b              ASRS     r3,r1,#12
                  |L1.344|
;;;482          if ((LPC_EMAC->MIND & MIND_BUSY) == 0) {
000158  6b4a              LDR      r2,[r1,#0x34]
00015a  07d2              LSLS     r2,r2,#31
00015c  d002              BEQ      |L1.356|
00015e  1c40              ADDS     r0,r0,#1              ;481
000160  4298              CMP      r0,r3                 ;481
000162  d3f9              BCC      |L1.344|
                  |L1.356|
;;;483            break;
;;;484          }
;;;485        }
;;;486        LPC_EMAC->MCMD = 0;
000164  2000              MOVS     r0,#0
000166  6248              STR      r0,[r1,#0x24]
;;;487        val = LPC_EMAC->MRDD;
000168  6b0c              LDR      r4,[r1,#0x30]
                  |L1.362|
;;;488      }
;;;489      return (val);
00016a  b2a0              UXTH     r0,r4
;;;490    }
00016c  bd10              POP      {r4,pc}
;;;491    
                          ENDP

                  write_PHY PROC
;;;398    
;;;399    static void write_PHY (U32 PhyReg, U16 Value) {
00016e  b570              PUSH     {r4-r6,lr}
000170  4605              MOV      r5,r0
000172  460c              MOV      r4,r1
;;;400      /* Write a data 'Value' to PHY register 'PhyReg'. */
;;;401      U32 tout;
;;;402    
;;;403      if (dev_175x == __TRUE) {
000174  48a9              LDR      r0,|L1.1052|
000176  7800              LDRB     r0,[r0,#0]  ; dev_175x
000178  2801              CMP      r0,#1
00017a  d120              BNE      |L1.446|
;;;404        /* Software MII Management for LPC175x. */
;;;405        /* Remapped MDC on P2.8 and MDIO on P2.9 do not work. */
;;;406        LPC_GPIO2->FIODIR |= MDIO;
00017c  48a6              LDR      r0,|L1.1048|
00017e  6c01              LDR      r1,[r0,#0x40]
000180  f4417100          ORR      r1,r1,#0x200
000184  6401              STR      r1,[r0,#0x40]
;;;407    
;;;408        /* 32 consecutive ones on MDO to establish sync */
;;;409        output_MDIO (0xFFFFFFFF, 32);
000186  2120              MOVS     r1,#0x20
000188  f04f30ff          MOV      r0,#0xffffffff
00018c  f7fffffe          BL       output_MDIO
;;;410    
;;;411        /* start code (01), write command (01) */
;;;412        output_MDIO (0x05, 4);
000190  2104              MOVS     r1,#4
000192  2005              MOVS     r0,#5
000194  f7fffffe          BL       output_MDIO
;;;413    
;;;414        /* write PHY address */
;;;415        output_MDIO (DP83848C_DEF_ADR >> 8, 5);
000198  2105              MOVS     r1,#5
00019a  2001              MOVS     r0,#1
00019c  f7fffffe          BL       output_MDIO
;;;416    
;;;417        /* write the PHY register to write */
;;;418        output_MDIO (PhyReg, 5);
0001a0  2105              MOVS     r1,#5
0001a2  4628              MOV      r0,r5
0001a4  f7fffffe          BL       output_MDIO
;;;419    
;;;420        /* turnaround MDIO (1,0)*/
;;;421        output_MDIO (0x02, 2);
0001a8  2102              MOVS     r1,#2
0001aa  4608              MOV      r0,r1
0001ac  f7fffffe          BL       output_MDIO
;;;422    
;;;423        /* write the data value */
;;;424        output_MDIO (Value, 16);
0001b0  2110              MOVS     r1,#0x10
0001b2  4620              MOV      r0,r4
0001b4  f7fffffe          BL       output_MDIO
;;;425    
;;;426        /* turnaround MDO is tristated */
;;;427        turnaround_MDIO ();
0001b8  e8bd4070          POP      {r4-r6,lr}
0001bc  e7fe              B        turnaround_MDIO
                  |L1.446|
;;;428      }
;;;429      else {
;;;430        /* Hardware MII Management for LPC176x devices. */
;;;431        LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
0001be  f4457080          ORR      r0,r5,#0x100
0001c2  f04f41a0          MOV      r1,#0x50000000
0001c6  6288              STR      r0,[r1,#0x28]
;;;432        LPC_EMAC->MWTD = Value;
0001c8  62cc              STR      r4,[r1,#0x2c]
;;;433    
;;;434        /* Wait utill operation completed */
;;;435        for (tout = 0; tout < MII_WR_TOUT; tout++) {
0001ca  2000              MOVS     r0,#0
0001cc  130b              ASRS     r3,r1,#12
                  |L1.462|
;;;436          if ((LPC_EMAC->MIND & MIND_BUSY) == 0) {
0001ce  6b4a              LDR      r2,[r1,#0x34]
0001d0  07d2              LSLS     r2,r2,#31
0001d2  d002              BEQ      |L1.474|
0001d4  1c40              ADDS     r0,r0,#1              ;435
0001d6  4298              CMP      r0,r3                 ;435
0001d8  d3f9              BCC      |L1.462|
                  |L1.474|
;;;437            break;
;;;438          }
;;;439        }
;;;440      }
;;;441    }
0001da  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP

                  init_ethernet PROC
;;;66     
;;;67     void init_ethernet (void) {
0001dc  e92d41fc          PUSH     {r2-r8,lr}
;;;68       /* Initialize the EMAC ethernet controller. */
;;;69       U32 regv,tout,id1,id2;
;;;70       U32 pb[2];
;;;71     
;;;72       dev_175x = __FALSE;
0001e0  4c8e              LDR      r4,|L1.1052|
0001e2  2600              MOVS     r6,#0
0001e4  7026              STRB     r6,[r4,#0]
;;;73       /* Read device ID with IAP*/
;;;74       pb[0] = 54;
0001e6  2036              MOVS     r0,#0x36
0001e8  9000              STR      r0,[sp,#0]
;;;75       iap_entry (&pb[0], &pb[0]);
0001ea  6862              LDR      r2,[r4,#4]  ; iap_entry
0001ec  4669              MOV      r1,sp
0001ee  4668              MOV      r0,sp
0001f0  4790              BLX      r2
;;;76       if ((pb[1] >> 24) == 0x25) {
0001f2  9801              LDR      r0,[sp,#4]
0001f4  2125              MOVS     r1,#0x25
0001f6  ebb16f10          CMP      r1,r0,LSR #24
0001fa  d101              BNE      |L1.512|
;;;77         /* Use software RMII management routines. */
;;;78         dev_175x = __TRUE;
0001fc  2001              MOVS     r0,#1
0001fe  7020              STRB     r0,[r4,#0]
                  |L1.512|
;;;79       }
;;;80     
;;;81       /* Power Up the EMAC controller. */
;;;82       LPC_SC->PCONP |= 0x40000000;
000200  4887              LDR      r0,|L1.1056|
000202  6801              LDR      r1,[r0,#0]
000204  f0414180          ORR      r1,r1,#0x40000000
000208  6001              STR      r1,[r0,#0]
;;;83     
;;;84       /* Enable P1 Ethernet Pins. */
;;;85       LPC_PINCON->PINSEL2 = 0x50150105;
00020a  4887              LDR      r0,|L1.1064|
00020c  4985              LDR      r1,|L1.1060|
00020e  6081              STR      r1,[r0,#8]
;;;86       if (dev_175x == __FALSE) {
000210  7821              LDRB     r1,[r4,#0]  ; dev_175x
000212  b929              CBNZ     r1,|L1.544|
;;;87         /* LPC176x devices, no MDIO, MDC remap. */
;;;88         LPC_PINCON->PINSEL3 = (LPC_PINCON->PINSEL3 & ~0x0000000F) | 0x00000005;
000214  68c1              LDR      r1,[r0,#0xc]
000216  f021010f          BIC      r1,r1,#0xf
00021a  1d49              ADDS     r1,r1,#5
00021c  60c1              STR      r1,[r0,#0xc]
00021e  e008              B        |L1.562|
                  |L1.544|
;;;89       }
;;;90       else {
;;;91         /* LPC175x devices, use software MII management. */  
;;;92         LPC_PINCON->PINSEL4 &= ~0x000F0000;
000220  6901              LDR      r1,[r0,#0x10]
000222  f4212170          BIC      r1,r1,#0xf0000
000226  6101              STR      r1,[r0,#0x10]
;;;93         LPC_GPIO2->FIODIR |= MDC;
000228  487b              LDR      r0,|L1.1048|
00022a  6c01              LDR      r1,[r0,#0x40]
00022c  f4417180          ORR      r1,r1,#0x100
000230  6401              STR      r1,[r0,#0x40]
                  |L1.562|
;;;94       }
;;;95     
;;;96       /* Reset all EMAC internal modules. */
;;;97       LPC_EMAC->MAC1    = MAC1_RES_TX | MAC1_RES_MCS_TX | MAC1_RES_RX | 
000232  f44f404f          MOV      r0,#0xcf00
000236  f04f45a0          MOV      r5,#0x50000000
00023a  6028              STR      r0,[r5,#0]
;;;98                           MAC1_RES_MCS_RX | MAC1_SIM_RES | MAC1_SOFT_RES;
;;;99       LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
00023c  2078              MOVS     r0,#0x78
00023e  f8c50100          STR      r0,[r5,#0x100]
;;;100    
;;;101      /* A short delay after reset. */
;;;102      for (tout = 100; tout; tout--);
000242  2064              MOVS     r0,#0x64
                  |L1.580|
000244  1e40              SUBS     r0,r0,#1
000246  2800              CMP      r0,#0
000248  d1fc              BNE      |L1.580|
;;;103    
;;;104      /* Initialize MAC control registers. */
;;;105      LPC_EMAC->MAC1 = MAC1_PASS_ALL;
00024a  2002              MOVS     r0,#2
00024c  6028              STR      r0,[r5,#0]
;;;106      LPC_EMAC->MAC2 = MAC2_CRC_EN | MAC2_PAD_EN;
00024e  2030              MOVS     r0,#0x30
000250  6068              STR      r0,[r5,#4]
;;;107      LPC_EMAC->MAXF = ETH_MAX_FLEN;
000252  0140              LSLS     r0,r0,#5
000254  6168              STR      r0,[r5,#0x14]
;;;108      LPC_EMAC->CLRT = CLRT_DEF;
000256  f243700f          MOV      r0,#0x370f
00025a  6128              STR      r0,[r5,#0x10]
;;;109      LPC_EMAC->IPGR = IPGR_DEF;
00025c  2712              MOVS     r7,#0x12
00025e  60ef              STR      r7,[r5,#0xc]
;;;110    
;;;111      /* Enable Reduced MII interface. */
;;;112      LPC_EMAC->Command = CR_RMII | CR_PASS_RUNT_FRM;
000260  0178              LSLS     r0,r7,#5
000262  f8c50100          STR      r0,[r5,#0x100]
;;;113    
;;;114      /* Reset Reduced MII Logic. */
;;;115      LPC_EMAC->SUPP = SUPP_RES_RMII;
000266  f44f6000          MOV      r0,#0x800
00026a  61a8              STR      r0,[r5,#0x18]
;;;116      for (tout = 100; tout; tout--);
00026c  2464              MOVS     r4,#0x64
                  |L1.622|
00026e  1e64              SUBS     r4,r4,#1
000270  2c00              CMP      r4,#0
000272  d1fc              BNE      |L1.622|
;;;117      LPC_EMAC->SUPP = 0;
000274  61ae              STR      r6,[r5,#0x18]
;;;118    
;;;119      /* Put the DP83848C in reset mode */
;;;120      write_PHY (PHY_REG_BMCR, 0x8000);
000276  f44f4100          MOV      r1,#0x8000
00027a  2000              MOVS     r0,#0
00027c  f7fffffe          BL       write_PHY
;;;121    
;;;122      /* Wait for hardware reset to end. */
;;;123      for (tout = 0; tout < 0x100000; tout++) {
000280  f44f1880          MOV      r8,#0x100000
                  |L1.644|
;;;124        regv = read_PHY (PHY_REG_BMCR);
000284  2000              MOVS     r0,#0
000286  f7fffffe          BL       read_PHY
;;;125        if (!(regv & 0x8800)) {
00028a  f4104f08          TST      r0,#0x8800
00028e  d002              BEQ      |L1.662|
000290  1c64              ADDS     r4,r4,#1              ;123
000292  4544              CMP      r4,r8                 ;123
000294  d3f6              BCC      |L1.644|
                  |L1.662|
;;;126          /* Reset complete, device not Power Down. */
;;;127          break;
;;;128        }
;;;129      }
;;;130    
;;;131      /* Check if this is a DP83848C PHY. */
;;;132      id1 = read_PHY (PHY_REG_IDR1);
000296  2002              MOVS     r0,#2
000298  f7fffffe          BL       read_PHY
00029c  4604              MOV      r4,r0
;;;133      id2 = read_PHY (PHY_REG_IDR2);
00029e  2003              MOVS     r0,#3
0002a0  f7fffffe          BL       read_PHY
;;;134    
;;;135      if (((id1 << 16) | (id2 & 0xFFF0)) == DP83848C_ID) {
0002a4  f64f71f0          MOV      r1,#0xfff0
0002a8  4008              ANDS     r0,r0,r1
0002aa  4960              LDR      r1,|L1.1068|
0002ac  ea404004          ORR      r0,r0,r4,LSL #16
0002b0  4288              CMP      r0,r1
0002b2  d10d              BNE      |L1.720|
;;;136        /* Configure the PHY device */
;;;137    #if defined (_10MBIT_)
;;;138        /* Connect at 10MBit */
;;;139        write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);
;;;140    #elif defined (_100MBIT_)
;;;141        /* Connect at 100MBit */
;;;142        write_PHY (PHY_REG_BMCR, PHY_FULLD_100M);
;;;143    #else
;;;144        /* Use autonegotiation about the link speed. */
;;;145        write_PHY (PHY_REG_BMCR, PHY_AUTO_NEG);
0002b4  f44f5140          MOV      r1,#0x3000
0002b8  2000              MOVS     r0,#0
0002ba  f7fffffe          BL       write_PHY
;;;146        /* Wait to complete Auto_Negotiation. */
;;;147        for (tout = 0; tout < 0x100000; tout++) {
0002be  2400              MOVS     r4,#0
                  |L1.704|
;;;148          regv = read_PHY (PHY_REG_BMSR);
0002c0  2001              MOVS     r0,#1
0002c2  f7fffffe          BL       read_PHY
;;;149          if (regv & 0x0020) {
0002c6  0680              LSLS     r0,r0,#26
0002c8  d402              BMI      |L1.720|
0002ca  1c64              ADDS     r4,r4,#1              ;147
0002cc  4544              CMP      r4,r8                 ;147
0002ce  d3f7              BCC      |L1.704|
                  |L1.720|
;;;150            /* Autonegotiation Complete. */
;;;151            break;
;;;152          }
;;;153        }
;;;154    #endif
;;;155      }
;;;156    
;;;157      /* Check the link status. */
;;;158      for (tout = 0; tout < 0x10000; tout++) {
0002d0  2400              MOVS     r4,#0
0002d2  f44f3880          MOV      r8,#0x10000
                  |L1.726|
;;;159        regv = read_PHY (PHY_REG_STS);
0002d6  2010              MOVS     r0,#0x10
0002d8  f7fffffe          BL       read_PHY
;;;160        if (regv & 0x0001) {
0002dc  07c1              LSLS     r1,r0,#31
0002de  d102              BNE      |L1.742|
0002e0  1c64              ADDS     r4,r4,#1              ;158
0002e2  4544              CMP      r4,r8                 ;158
0002e4  d3f7              BCC      |L1.726|
                  |L1.742|
;;;161          /* Link is on. */
;;;162          break;
;;;163        }
;;;164      }
;;;165    
;;;166      /* Configure Full/Half Duplex mode. */
;;;167      if (regv & 0x0004) {
0002e6  0741              LSLS     r1,r0,#29
0002e8  d50c              BPL      |L1.772|
;;;168        /* Full duplex is enabled. */
;;;169        LPC_EMAC->MAC2    |= MAC2_FULL_DUP;
0002ea  6869              LDR      r1,[r5,#4]
0002ec  f0410101          ORR      r1,r1,#1
0002f0  6069              STR      r1,[r5,#4]
;;;170        LPC_EMAC->Command |= CR_FULL_DUP;
0002f2  f8d51100          LDR      r1,[r5,#0x100]
0002f6  f4416180          ORR      r1,r1,#0x400
0002fa  f8c51100          STR      r1,[r5,#0x100]
;;;171        LPC_EMAC->IPGT     = IPGT_FULL_DUP;
0002fe  2115              MOVS     r1,#0x15
000300  60a9              STR      r1,[r5,#8]
000302  e000              B        |L1.774|
                  |L1.772|
;;;172      }
;;;173      else {
;;;174        /* Half duplex mode. */
;;;175        LPC_EMAC->IPGT = IPGT_HALF_DUP;
000304  60af              STR      r7,[r5,#8]
                  |L1.774|
;;;176      }
;;;177    
;;;178      /* Configure 100MBit/10MBit mode. */
;;;179      if (regv & 0x0002) {
000306  0780              LSLS     r0,r0,#30
000308  d501              BPL      |L1.782|
;;;180        /* 10MBit mode. */
;;;181        LPC_EMAC->SUPP = 0;
00030a  61ae              STR      r6,[r5,#0x18]
00030c  e002              B        |L1.788|
                  |L1.782|
;;;182      }
;;;183      else {
;;;184        /* 100MBit mode. */
;;;185        LPC_EMAC->SUPP = SUPP_SPEED;
00030e  f44f7080          MOV      r0,#0x100
000312  61a8              STR      r0,[r5,#0x18]
                  |L1.788|
;;;186      }
;;;187    
;;;188      /* Set the Ethernet MAC Address registers */
;;;189      LPC_EMAC->SA0 = ((U32)own_hw_adr[5] << 8) | (U32)own_hw_adr[4];
000314  4846              LDR      r0,|L1.1072|
000316  7901              LDRB     r1,[r0,#4]  ; own_hw_adr
000318  7942              LDRB     r2,[r0,#5]  ; own_hw_adr
00031a  ea412102          ORR      r1,r1,r2,LSL #8
00031e  6429              STR      r1,[r5,#0x40]
;;;190      LPC_EMAC->SA1 = ((U32)own_hw_adr[3] << 8) | (U32)own_hw_adr[2];
000320  7881              LDRB     r1,[r0,#2]  ; own_hw_adr
000322  78c2              LDRB     r2,[r0,#3]  ; own_hw_adr
000324  ea412102          ORR      r1,r1,r2,LSL #8
000328  6469              STR      r1,[r5,#0x44]
;;;191      LPC_EMAC->SA2 = ((U32)own_hw_adr[1] << 8) | (U32)own_hw_adr[0];
00032a  7801              LDRB     r1,[r0,#0]  ; own_hw_adr
00032c  7840              LDRB     r0,[r0,#1]  ; own_hw_adr
00032e  ea412000          ORR      r0,r1,r0,LSL #8
000332  64a8              STR      r0,[r5,#0x48]
;;;192    
;;;193      /* Initialize Tx and Rx DMA Descriptors */
;;;194      rx_descr_init ();
000334  f7fffffe          BL       rx_descr_init
;;;195      tx_descr_init ();
000338  f7fffffe          BL       tx_descr_init
;;;196    
;;;197      /* Receive Broadcast, Multicast and Perfect Match Packets */
;;;198      LPC_EMAC->RxFilterCtrl = RFC_MCAST_EN | RFC_BCAST_EN | RFC_PERFECT_EN;
00033c  2026              MOVS     r0,#0x26
00033e  f8c50200          STR      r0,[r5,#0x200]
;;;199    
;;;200      /* Enable EMAC interrupts. */
;;;201      LPC_EMAC->IntEnable = INT_RX_DONE | INT_TX_DONE;
000342  2088              MOVS     r0,#0x88
000344  f8c50fe4          STR      r0,[r5,#0xfe4]
;;;202    
;;;203      /* Reset all interrupts */
;;;204      LPC_EMAC->IntClear  = 0xFFFF;
000348  f64f70ff          MOV      r0,#0xffff
00034c  f8c50fe8          STR      r0,[r5,#0xfe8]
;;;205    
;;;206      /* Enable receive and transmit mode of MAC Ethernet core */
;;;207      LPC_EMAC->Command  |= (CR_RX_EN | CR_TX_EN);
000350  f8d50100          LDR      r0,[r5,#0x100]
000354  f0400003          ORR      r0,r0,#3
000358  f8c50100          STR      r0,[r5,#0x100]
;;;208      LPC_EMAC->MAC1     |= MAC1_REC_EN;
00035c  6828              LDR      r0,[r5,#0]
00035e  f0400001          ORR      r0,r0,#1
000362  6028              STR      r0,[r5,#0]
;;;209    
;;;210    }
000364  e8bd81fc          POP      {r2-r8,pc}
;;;211    
                          ENDP

                  int_enable_eth PROC
;;;214    
;;;215    void int_enable_eth (void) {
000368  4832              LDR      r0,|L1.1076|
00036a  f04f5180          MOV      r1,#0x10000000
00036e  6001              STR      r1,[r0,#0]
;;;216      /* Ethernet Interrupt Enable function. */
;;;217      NVIC_EnableIRQ(ENET_IRQn);
;;;218    }
000370  4770              BX       lr
;;;219    
                          ENDP

                  int_disable_eth PROC
;;;222    
;;;223    void int_disable_eth (void) {
000372  4831              LDR      r0,|L1.1080|
000374  f04f5180          MOV      r1,#0x10000000
000378  6001              STR      r1,[r0,#0]
;;;224      /* Ethernet Interrupt Disable function. */
;;;225      NVIC_DisableIRQ(ENET_IRQn);
;;;226    }
00037a  4770              BX       lr
;;;227    
                          ENDP

                  send_frame PROC
;;;230    
;;;231    void send_frame (OS_FRAME *frame) {
00037c  b5f0              PUSH     {r4-r7,lr}
;;;232      /* Send frame to EMAC ethernet controller */
;;;233      U32 idx,len;
;;;234      U32 *sp,*dp;
;;;235    
;;;236      idx = LPC_EMAC->TxProduceIndex;
00037e  f04f45a0          MOV      r5,#0x50000000
000382  f8d54128          LDR      r4,[r5,#0x128]
;;;237      sp  = (U32 *)&frame->data[0];
000386  1d02              ADDS     r2,r0,#4
;;;238      dp  = (U32 *)Tx_Desc[idx].Packet;
000388  4e1f              LDR      r6,|L1.1032|
00038a  f8563034          LDR      r3,[r6,r4,LSL #3]
;;;239    
;;;240      /* Copy frame data to EMAC packet buffers. */
;;;241      for (len = (frame->length + 3) >> 2; len; len--) {
00038e  8801              LDRH     r1,[r0,#0]
000390  1cc9              ADDS     r1,r1,#3
000392  0889              LSRS     r1,r1,#2
000394  b121              CBZ      r1,|L1.928|
                  |L1.918|
;;;242        *dp++ = *sp++;
000396  ca80              LDM      r2!,{r7}
000398  c380              STM      r3!,{r7}
00039a  1e49              SUBS     r1,r1,#1              ;241
00039c  2900              CMP      r1,#0                 ;241
00039e  d1fa              BNE      |L1.918|
                  |L1.928|
;;;243      }
;;;244      Tx_Desc[idx].Ctrl = (frame->length-1) | (TCTRL_INT | TCTRL_LAST);
0003a0  8800              LDRH     r0,[r0,#0]
0003a2  eb0601c4          ADD      r1,r6,r4,LSL #3
0003a6  1e40              SUBS     r0,r0,#1
0003a8  f0404040          ORR      r0,r0,#0xc0000000
0003ac  6048              STR      r0,[r1,#4]
;;;245    
;;;246      /* Start frame transmission. */
;;;247      if (++idx == NUM_TX_FRAG) idx = 0;
0003ae  1c64              ADDS     r4,r4,#1
0003b0  2c03              CMP      r4,#3
0003b2  d100              BNE      |L1.950|
0003b4  2400              MOVS     r4,#0
                  |L1.950|
;;;248      LPC_EMAC->TxProduceIndex = idx;
0003b6  f8c54128          STR      r4,[r5,#0x128]
;;;249    }
0003ba  bdf0              POP      {r4-r7,pc}
;;;250    
                          ENDP

                  ENET_IRQHandler PROC
;;;253    
;;;254    void ENET_IRQHandler (void) {
0003bc  b570              PUSH     {r4-r6,lr}
;;;255      /* EMAC Ethernet Controller Interrupt function. */
;;;256      OS_FRAME *frame;
;;;257      U32 idx,int_stat,RxLen,info;
;;;258      U32 *sp,*dp;
;;;259    
;;;260      while ((int_stat = (LPC_EMAC->IntStatus & LPC_EMAC->IntEnable)) != 0) {
;;;261        LPC_EMAC->IntClear = int_stat;
0003be  f04f46a0          MOV      r6,#0x50000000
0003c2  e053              B        |L1.1132|
                  |L1.964|
0003c4  f8c60fe8          STR      r0,[r6,#0xfe8]
;;;262        if (int_stat & INT_RX_DONE) {
0003c8  0700              LSLS     r0,r0,#28
0003ca  d54f              BPL      |L1.1132|
;;;263          /* Packet received, check if packet is valid. */
;;;264          idx = LPC_EMAC->RxConsumeIndex;
0003cc  f8d64118          LDR      r4,[r6,#0x118]
;;;265          while (idx != LPC_EMAC->RxProduceIndex) {
0003d0  e048              B        |L1.1124|
                  |L1.978|
;;;266            info = Rx_Stat[idx].Info;
0003d2  480d              LDR      r0,|L1.1032|
0003d4  3820              SUBS     r0,r0,#0x20
0003d6  f8500034          LDR      r0,[r0,r4,LSL #3]
;;;267            if (!(info & RINFO_LAST_FLAG)) {
0003da  0041              LSLS     r1,r0,#1
0003dc  d53c              BPL      |L1.1112|
;;;268              goto rel;
;;;269            }
;;;270    
;;;271            RxLen = (info & RINFO_SIZE) - 3;
0003de  f3c0050a          UBFX     r5,r0,#0,#11
0003e2  1eed              SUBS     r5,r5,#3
;;;272            if (RxLen > ETH_MTU || (info & RINFO_ERR_MASK)) {
0003e4  f24051ea          MOV      r1,#0x5ea
0003e8  428d              CMP      r5,r1
0003ea  d835              BHI      |L1.1112|
0003ec  4913              LDR      r1,|L1.1084|
0003ee  4208              TST      r0,r1
0003f0  d132              BNE      |L1.1112|
;;;273              /* Invalid frame, ignore it and free buffer. */
;;;274              goto rel;
;;;275            }
;;;276            /* Flag 0x80000000 to skip sys_error() call when out of memory. */
;;;277            frame = alloc_mem (RxLen | 0x80000000);
0003f2  f0454000          ORR      r0,r5,#0x80000000
0003f6  f7fffffe          BL       alloc_mem
;;;278            /* if 'alloc_mem()' has failed, ignore this packet. */
;;;279            if (frame != NULL) {
0003fa  b368              CBZ      r0,|L1.1112|
;;;280              dp = (U32 *)&frame->data[0];
0003fc  1d02              ADDS     r2,r0,#4
;;;281              sp = (U32 *)Rx_Desc[idx].Packet;
0003fe  4902              LDR      r1,|L1.1032|
000400  3940              SUBS     r1,r1,#0x40
000402  e01d              B        |L1.1088|
                  |L1.1028|
                          DCD      ||.bss||+0x1864
                  |L1.1032|
                          DCD      ||.bss||+0x40
                  |L1.1036|
                          DCD      0x5000011c
                  |L1.1040|
                          DCD      0x800005ff
                  |L1.1044|
                          DCD      0x50000108
                  |L1.1048|
                          DCD      0x2009c000
                  |L1.1052|
                          DCD      ||.data||
                  |L1.1056|
                          DCD      0x400fc0c4
                  |L1.1060|
                          DCD      0x50150105
                  |L1.1064|
                          DCD      0x4002c000
                  |L1.1068|
                          DCD      0x20005c90
                  |L1.1072|
                          DCD      own_hw_adr
                  |L1.1076|
                          DCD      0xe000e100
                  |L1.1080|
                          DCD      0xe000e180
                  |L1.1084|
                          DCD      0x1b900000
                  |L1.1088|
000440  f8513034          LDR      r3,[r1,r4,LSL #3]
;;;282              for (RxLen = (RxLen + 3) >> 2; RxLen; RxLen--) {
000444  1ced              ADDS     r5,r5,#3
000446  08a9              LSRS     r1,r5,#2
000448  b121              CBZ      r1,|L1.1108|
                  |L1.1098|
;;;283                *dp++ = *sp++;
00044a  cb20              LDM      r3!,{r5}
00044c  c220              STM      r2!,{r5}
00044e  1e49              SUBS     r1,r1,#1              ;282
000450  2900              CMP      r1,#0                 ;282
000452  d1fa              BNE      |L1.1098|
                  |L1.1108|
;;;284              }
;;;285              put_in_queue (frame);
000454  f7fffffe          BL       put_in_queue
                  |L1.1112|
;;;286            }
;;;287    rel:    if (++idx == NUM_RX_FRAG) idx = 0;
000458  1c64              ADDS     r4,r4,#1
00045a  2c04              CMP      r4,#4
00045c  d100              BNE      |L1.1120|
00045e  2400              MOVS     r4,#0
                  |L1.1120|
;;;288            /* Release frame from EMAC buffer. */
;;;289            LPC_EMAC->RxConsumeIndex = idx;
000460  f8c64118          STR      r4,[r6,#0x118]
                  |L1.1124|
000464  f8d60114          LDR      r0,[r6,#0x114]        ;265
000468  42a0              CMP      r0,r4                 ;265
00046a  d1b2              BNE      |L1.978|
                  |L1.1132|
00046c  f8d60fe0          LDR      r0,[r6,#0xfe0]        ;260
000470  f8d61fe4          LDR      r1,[r6,#0xfe4]        ;260
000474  4008              ANDS     r0,r0,r1              ;260
000476  d1a5              BNE      |L1.964|
;;;290          }
;;;291        }
;;;292        if (int_stat & INT_TX_DONE) {
;;;293          /* Frame transmit completed. */
;;;294        }
;;;295      }
;;;296    
;;;297    }
000478  bd70              POP      {r4-r6,pc}
;;;298    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  Rx_Desc
                          %        32
                  Rx_Stat
                          %        32
                  Tx_Desc
                          %        24
                  Tx_Stat
                          %        12
                  rx_buf
                          %        6144
                  tx_buf
                          %        4608

                          AREA ||.data||, DATA, ALIGN=2

                  dev_175x
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  iap_entry
                          DCD      0x1fff1ff1
