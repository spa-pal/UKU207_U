; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\EXE\uart1.o --asm_dir=.\ --list_dir=.\ --depend=.\EXE\uart1.d --cpu=Cortex-M3 --apcs=interwork -O1 -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\NXP\LPC17xx -D__MICROLIB -DUKU_220_IPS_TERMOKOMPENSAT -DUKU2071x -DUKU_ZVU --omf_browse=.\EXE\uart1.crf uart1.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  putchar1 PROC
;;;37     //-----------------------------------------------
;;;38     void putchar1(char c)
000000  b530              PUSH     {r4,r5,lr}
;;;39     {
;;;40     while (tx_counter1 == TX_BUFFER_SIZE1);
000002  4bfd              LDR      r3,|L1.1016|
000004  f44f7496          MOV      r4,#0x12c
000008  8a59              LDRH     r1,[r3,#0x12]
                  |L1.10|
00000a  42a1              CMP      r1,r4
00000c  d0fd              BEQ      |L1.10|
;;;41     if (tx_counter1 || ((LPC_UART1->LSR & 0x60)==0))
00000e  b9b1              CBNZ     r1,|L1.62|
000010  4afa              LDR      r2,|L1.1020|
000012  7d15              LDRB     r5,[r2,#0x14]
000014  f0150f60          TST      r5,#0x60
000018  d011              BEQ      |L1.62|
;;;42        {
;;;43        tx_buffer1[tx_wr_index1]=c;
;;;44        if (++tx_wr_index1 == TX_BUFFER_SIZE1) tx_wr_index1=0;
;;;45        ++tx_counter1;
;;;46        }
;;;47     else
;;;48     	{
;;;49     	LPC_PINCON->PINSEL4 &= ~0x0000c000;//!!!!!!!!!!!
00001a  49f9              LDR      r1,|L1.1024|
00001c  690b              LDR      r3,[r1,#0x10]
00001e  f4234340          BIC      r3,r3,#0xc000
000022  610b              STR      r3,[r1,#0x10]
;;;50     	LPC_PINCON->PINSEL4 |= 0x00000000; //!!!!!!!!!!! 
000024  690b              LDR      r3,[r1,#0x10]
000026  610b              STR      r3,[r1,#0x10]
;;;51     	LPC_GPIO2->FIODIR|=(1UL<<2);
000028  49f6              LDR      r1,|L1.1028|
00002a  6c0b              LDR      r3,[r1,#0x40]
00002c  f0430304          ORR      r3,r3,#4
000030  640b              STR      r3,[r1,#0x40]
;;;52     	LPC_GPIO2->FIOPIN|=(1UL<<2);
000032  6d4b              LDR      r3,[r1,#0x54]
000034  f0430304          ORR      r3,r3,#4
000038  654b              STR      r3,[r1,#0x54]
;;;53     	LPC_UART1->THR=c;
00003a  7010              STRB     r0,[r2,#0]
;;;54     	} 
;;;55     }
00003c  bd30              POP      {r4,r5,pc}
                  |L1.62|
00003e  4df2              LDR      r5,|L1.1032|
000040  89da              LDRH     r2,[r3,#0xe]          ;43  ; tx_wr_index1
000042  54a8              STRB     r0,[r5,r2]            ;43
000044  1c52              ADDS     r2,r2,#1              ;44
000046  b290              UXTH     r0,r2                 ;44
000048  81d8              STRH     r0,[r3,#0xe]          ;44
00004a  42a0              CMP      r0,r4                 ;44
00004c  d102              BNE      |L1.84|
00004e  f04f0000          MOV      r0,#0                 ;44
000052  81d8              STRH     r0,[r3,#0xe]          ;44
                  |L1.84|
000054  f1010101          ADD      r1,r1,#1              ;45
000058  8259              STRH     r1,[r3,#0x12]         ;45
00005a  bd30              POP      {r4,r5,pc}
;;;56     
                          ENDP

                  uart_out1 PROC
;;;57     //-----------------------------------------------
;;;58     void uart_out1 (char num,char data0,char data1,char data2,char data3,char data4,char data5)
00005c  b5ff              PUSH     {r0-r7,lr}
;;;59     {                
00005e  ad09              ADD      r5,sp,#0x24
000060  cde0              LDM      r5,{r5-r7}
;;;60     char i,t=0;
000062  f04f0400          MOV      r4,#0
;;;61     //char *ptr=&data1;
;;;62     char UOB1[16]; 
;;;63     UOB1[0]=data0;
000066  f88d1000          STRB     r1,[sp,#0]
;;;64     UOB1[1]=data1;
00006a  f88d2001          STRB     r2,[sp,#1]
;;;65     UOB1[2]=data2;
00006e  f88d3002          STRB     r3,[sp,#2]
;;;66     UOB1[3]=data3;
000072  f88d5003          STRB     r5,[sp,#3]
;;;67     UOB1[4]=data4;
000076  f88d6004          STRB     r6,[sp,#4]
;;;68     UOB1[5]=data5;
00007a  f88d7005          STRB     r7,[sp,#5]
;;;69     
;;;70     for (i=0;i<num;i++)
00007e  4621              MOV      r1,r4
000080  466d              MOV      r5,sp                 ;62
000082  e005              B        |L1.144|
                  |L1.132|
;;;71     	{
;;;72     	t^=UOB1[i];
000084  5c6a              LDRB     r2,[r5,r1]
000086  ea820404          EOR      r4,r2,r4
00008a  f1010101          ADD      r1,r1,#1              ;70
00008e  b2c9              UXTB     r1,r1                 ;70
                  |L1.144|
000090  4281              CMP      r1,r0                 ;70
000092  d3f7              BCC      |L1.132|
;;;73     	}    
;;;74     UOB1[num]=num;
000094  5428              STRB     r0,[r5,r0]
;;;75     t^=UOB1[num];
000096  ea800204          EOR      r2,r0,r4
;;;76     UOB1[num+1]=t;
00009a  eb050100          ADD      r1,r5,r0
00009e  704a              STRB     r2,[r1,#1]
;;;77     UOB1[num+2]=END;
0000a0  f04f020a          MOV      r2,#0xa
0000a4  708a              STRB     r2,[r1,#2]
;;;78     
;;;79     for (i=0;i<num+3;i++)
0000a6  f04f0400          MOV      r4,#0
0000aa  f1000603          ADD      r6,r0,#3
0000ae  e005              B        |L1.188|
                  |L1.176|
;;;80     	{
;;;81     	putchar1(UOB1[i]);
0000b0  5d28              LDRB     r0,[r5,r4]
0000b2  f7fffffe          BL       putchar1
0000b6  f1040401          ADD      r4,r4,#1              ;79
0000ba  b2e4              UXTB     r4,r4                 ;79
                  |L1.188|
0000bc  42b4              CMP      r4,r6                 ;79
0000be  d3f7              BCC      |L1.176|
;;;82     	}   	
;;;83     }
0000c0  bdff              POP      {r0-r7,pc}
;;;84     
                          ENDP

                  uart_out_adr1 PROC
;;;85     //-----------------------------------------------
;;;86     void uart_out_adr1 (char *ptr, unsigned char len)
0000c2  b570              PUSH     {r4-r6,lr}
;;;87     {
0000c4  b0cb              SUB      sp,sp,#0x12c
;;;88     char UOB[300]/*={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}*/;
;;;89     unsigned char i,t=0;
0000c6  f04f0300          MOV      r3,#0
;;;90     
;;;91     //suzz[3]++;
;;;92     
;;;93     for(i=0;i<len;i++)
0000ca  461a              MOV      r2,r3
0000cc  466d              MOV      r5,sp                 ;88
0000ce  e006              B        |L1.222|
                  |L1.208|
;;;94     	{
;;;95     	UOB[i]=ptr[i];
0000d0  5c84              LDRB     r4,[r0,r2]
0000d2  54ac              STRB     r4,[r5,r2]
;;;96     	t^=UOB[i];
0000d4  ea840303          EOR      r3,r4,r3
0000d8  f1020201          ADD      r2,r2,#1              ;93
0000dc  b2d2              UXTB     r2,r2                 ;93
                  |L1.222|
0000de  428a              CMP      r2,r1                 ;93
0000e0  d3f6              BCC      |L1.208|
;;;97     	}
;;;98     
;;;99     UOB[len]=len;
0000e2  5469              STRB     r1,[r5,r1]
;;;100    t^=len;	
0000e4  ea830301          EOR      r3,r3,r1
;;;101    UOB[len+1]=t;	
0000e8  eb050001          ADD      r0,r5,r1
0000ec  7043              STRB     r3,[r0,#1]
;;;102    UOB[len+2]=END;
0000ee  f04f020a          MOV      r2,#0xa
0000f2  7082              STRB     r2,[r0,#2]
;;;103     
;;;104    for (i=0;i<len+3;i++)
0000f4  f04f0400          MOV      r4,#0
0000f8  f1010603          ADD      r6,r1,#3
0000fc  e005              B        |L1.266|
                  |L1.254|
;;;105    	{
;;;106    	putchar1(UOB[i]);
0000fe  5d28              LDRB     r0,[r5,r4]
000100  f7fffffe          BL       putchar1
000104  f1040401          ADD      r4,r4,#1              ;104
000108  b2e4              UXTB     r4,r4                 ;104
                  |L1.266|
00010a  42b4              CMP      r4,r6                 ;104
00010c  d3f7              BCC      |L1.254|
                  |L1.270|
;;;107    	}   
;;;108    }
00010e  b04b              ADD      sp,sp,#0x12c
000110  bd70              POP      {r4-r6,pc}
;;;109    
                          ENDP

                  uart_out__adr1 PROC
;;;110    //-----------------------------------------------
;;;111    void uart_out__adr1 (char *ptr, unsigned char len)
000112  b570              PUSH     {r4-r6,lr}
;;;112    {
000114  b0cb              SUB      sp,sp,#0x12c
000116  460d              MOV      r5,r1
;;;113    char UOB[300]/*={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}*/;
;;;114    unsigned char i,t=0;
;;;115    
;;;116    //suzz[3]++;
;;;117    
;;;118    for(i=0;i<len;i++)
000118  f04f0200          MOV      r2,#0
00011c  466e              MOV      r6,sp                 ;113
00011e  e004              B        |L1.298|
                  |L1.288|
;;;119    	{
;;;120    	UOB[i]=ptr[i];
000120  5c81              LDRB     r1,[r0,r2]
000122  54b1              STRB     r1,[r6,r2]
000124  f1020201          ADD      r2,r2,#1              ;118
000128  b2d2              UXTB     r2,r2                 ;118
                  |L1.298|
00012a  42aa              CMP      r2,r5                 ;118
00012c  d3f8              BCC      |L1.288|
;;;121    	t^=UOB[i];
;;;122    	}
;;;123    /*
;;;124    UOB[len]=len;
;;;125    t^=len;	
;;;126    UOB[len+1]=t;	
;;;127    UOB[len+2]=END;*/
;;;128     
;;;129    for (i=0;i<len;i++)
00012e  f04f0400          MOV      r4,#0
000132  e005              B        |L1.320|
                  |L1.308|
;;;130    	{
;;;131    	putchar1(UOB[i]);
000134  5d30              LDRB     r0,[r6,r4]
000136  f7fffffe          BL       putchar1
00013a  f1040401          ADD      r4,r4,#1              ;129
00013e  b2e4              UXTB     r4,r4                 ;129
                  |L1.320|
000140  42ac              CMP      r4,r5                 ;129
000142  d3f7              BCC      |L1.308|
;;;132    	}   
;;;133    }
000144  e7e3              B        |L1.270|
;;;134    //-----------------------------------------------
                          ENDP

                  uart1_init PROC
;;;135    uint32_t uart1_init(uint32_t baudrate)
000146  49ae              LDR      r1,|L1.1024|
;;;136    {
;;;137    uint32_t Fdiv;
;;;138    uint32_t pclkdiv, pclk;
;;;139    
;;;140    LPC_PINCON->PINSEL4 &= ~0x0000000F;
000148  690a              LDR      r2,[r1,#0x10]
00014a  f022020f          BIC      r2,r2,#0xf
00014e  610a              STR      r2,[r1,#0x10]
;;;141    LPC_PINCON->PINSEL4 |= 0x0000000A;	/* Enable RxD1 P2.1, TxD1 P2.0 */
000150  690a              LDR      r2,[r1,#0x10]
000152  f042020a          ORR      r2,r2,#0xa
000156  610a              STR      r2,[r1,#0x10]
;;;142    
;;;143    LPC_PINCON->PINSEL4 &= ~0x00000030;//!!!!!!!!!!!
000158  690a              LDR      r2,[r1,#0x10]
00015a  f0220230          BIC      r2,r2,#0x30
00015e  610a              STR      r2,[r1,#0x10]
;;;144    LPC_PINCON->PINSEL4 |= 0x00000000; //!!!!!!!!!!! 
000160  690a              LDR      r2,[r1,#0x10]
000162  610a              STR      r2,[r1,#0x10]
;;;145    LPC_GPIO2->FIODIR|=(1UL<<2);
000164  49a7              LDR      r1,|L1.1028|
000166  6c0a              LDR      r2,[r1,#0x40]
000168  f0420204          ORR      r2,r2,#4
00016c  640a              STR      r2,[r1,#0x40]
;;;146    LPC_GPIO2->FIOPIN&=~(1UL<<2);
00016e  6d4a              LDR      r2,[r1,#0x54]
000170  f0220204          BIC      r2,r2,#4
000174  654a              STR      r2,[r1,#0x54]
;;;147    
;;;148    pclkdiv = (LPC_SC->PCLKSEL0 >> 8) & 0x03;
000176  49a5              LDR      r1,|L1.1036|
000178  6809              LDR      r1,[r1,#0]
00017a  f3c12201          UBFX     r2,r1,#8,#2
;;;149    switch ( pclkdiv )
;;;150    	{
;;;151    	case 0x00:
;;;152    	default:
;;;153         pclk = SystemFrequency/4;
00017e  49a4              LDR      r1,|L1.1040|
000180  2a01              CMP      r2,#1                 ;149
000182  6809              LDR      r1,[r1,#0]
000184  d00b              BEQ      |L1.414|
000186  2a02              CMP      r2,#2                 ;149
000188  d004              BEQ      |L1.404|
00018a  2a03              CMP      r2,#3                 ;149
00018c  d005              BEQ      |L1.410|
00018e  ea4f0191          LSR      r1,r1,#2
;;;154    	break;
000192  e004              B        |L1.414|
                  |L1.404|
;;;155    	case 0x01:
;;;156    	pclk = SystemFrequency;
;;;157    	break; 
;;;158    	case 0x02:
;;;159    	pclk = SystemFrequency/2;
000194  ea4f0151          LSR      r1,r1,#1
;;;160    	break; 
000198  e001              B        |L1.414|
                  |L1.410|
;;;161    	case 0x03:
;;;162    	pclk = SystemFrequency/8;
00019a  ea4f01d1          LSR      r1,r1,#3
                  |L1.414|
;;;163    	break;
;;;164    	}
;;;165    
;;;166    LPC_UART1->LCR = 0x83;		/* 8 bits, no Parity, 1 Stop bit */
00019e  4a97              LDR      r2,|L1.1020|
0001a0  f04f0383          MOV      r3,#0x83
0001a4  7313              STRB     r3,[r2,#0xc]
;;;167    Fdiv = ( pclk / 16 ) / baudrate ;	/*baud rate */
0001a6  ea4f1111          LSR      r1,r1,#4
0001aa  fbb1f0f0          UDIV     r0,r1,r0
;;;168    LPC_UART1->DLM = Fdiv / 256;							
0001ae  ea4f2110          LSR      r1,r0,#8
0001b2  7111              STRB     r1,[r2,#4]
;;;169    LPC_UART1->DLL = Fdiv % 256;
0001b4  7010              STRB     r0,[r2,#0]
;;;170    LPC_UART1->LCR = 0x03;		/* DLAB = 0 */
0001b6  f04f0003          MOV      r0,#3
0001ba  7310              STRB     r0,[r2,#0xc]
;;;171    LPC_UART1->FCR = 0x07;		/* Enable and reset TX and RX FIFO. */
0001bc  f04f0007          MOV      r0,#7
0001c0  7210              STRB     r0,[r2,#8]
0001c2  4994              LDR      r1,|L1.1044|
0001c4  f04f0340          MOV      r3,#0x40
0001c8  600b              STR      r3,[r1,#0]
;;;172    
;;;173    NVIC_EnableIRQ(UART1_IRQn);
;;;174    
;;;175    LPC_UART1->IER = IER_RBR | IER_THRE | IER_RLS;	/* Enable UART1 interrupt */
0001ca  6050              STR      r0,[r2,#4]
;;;176    return (TRUE);
0001cc  f04f0001          MOV      r0,#1
;;;177    
;;;178    
;;;179    }
0001d0  4770              BX       lr
;;;180    
                          ENDP

                  getchar1 PROC
;;;182    //-----------------------------------------------
;;;183    char getchar1(void)
0001d2  4b89              LDR      r3,|L1.1016|
;;;184    {
;;;185    char data;
;;;186    while (rx_counter1==0);
0001d4  8999              LDRH     r1,[r3,#0xc]
                  |L1.470|
0001d6  2900              CMP      r1,#0
0001d8  d0fd              BEQ      |L1.470|
;;;187    data=rx_buffer1[rx_rd_index1];
0001da  488b              LDR      r0,|L1.1032|
0001dc  895a              LDRH     r2,[r3,#0xa]  ; rx_rd_index1
0001de  3864              SUBS     r0,r0,#0x64
0001e0  5c80              LDRB     r0,[r0,r2]
;;;188    if (++rx_rd_index1 == RX_BUFFER_SIZE1) rx_rd_index1=0;
0001e2  1c52              ADDS     r2,r2,#1
0001e4  b292              UXTH     r2,r2
0001e6  815a              STRH     r2,[r3,#0xa]
0001e8  2a64              CMP      r2,#0x64
0001ea  d102              BNE      |L1.498|
0001ec  f04f0200          MOV      r2,#0
0001f0  815a              STRH     r2,[r3,#0xa]
                  |L1.498|
;;;189    --rx_counter1;
0001f2  f1a10101          SUB      r1,r1,#1
0001f6  8199              STRH     r1,[r3,#0xc]
;;;190    return data;
;;;191    }
0001f8  4770              BX       lr
;;;192    
                          ENDP

                  UART1_IRQHandler PROC
;;;193    //***********************************************
;;;194    void UART1_IRQHandler (void) 
0001fa  e92d41f0          PUSH     {r4-r8,lr}
;;;195    {
;;;196    uint8_t IIRValue, LSRValue;
;;;197    uint8_t Dummy = Dummy;
;;;198    char /*status,u2iir,*/data;
;;;199    
;;;200    			
;;;201    IIRValue = LPC_UART1->IIR;
0001fe  4e7f              LDR      r6,|L1.1020|
000200  68b0              LDR      r0,[r6,#8]
;;;202        
;;;203    IIRValue >>= 1;			/* skip pending bit in IIR */
000202  ea4f0050          LSR      r0,r0,#1
;;;204    IIRValue &= 0x07;			/* check bit 1~3, interrupt identification */
000206  f0000007          AND      r0,r0,#7
;;;205    if ( IIRValue == IIR_RLS )		/* Receive Line Status */
;;;206      	{
;;;207    	LSRValue = LPC_UART1->LSR;
;;;208    	/* Receive Line Status */
;;;209    	
;;;210    	
;;;211    	
;;;212    	if ( LSRValue & (LSR_OE|LSR_PE|LSR_FE|LSR_RXFE|LSR_BI) )
;;;213    		{
;;;214    	  	/* There are errors or break interrupt */
;;;215    	  	/* Read LSR will clear the interrupt */
;;;216    	  	UART1Status = LSRValue;
00020a  497b              LDR      r1,|L1.1016|
;;;217    	  	Dummy = LPC_UART1->RBR;		/* Dummy read on RX to clear 
;;;218    							interrupt, then bail out */
;;;219    	  	return;
;;;220    		}
;;;221    	if ( LSRValue & LSR_RDR )	/* Receive Data Ready */			
;;;222    		{
;;;223    		
;;;224    		data=LPC_UART1->RBR;
;;;225    		rx_buffer1[rx_wr_index1]=data;
00020c  f8dfc1f8          LDR      r12,|L1.1032|
;;;226       		bRXIN1=1;
000210  f04f0701          MOV      r7,#1
000214  890d              LDRH     r5,[r1,#8]            ;225
000216  f1ac0c64          SUB      r12,r12,#0x64         ;225
;;;227       		if (++rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
00021a  f1050201          ADD      r2,r5,#1
00021e  b293              UXTH     r3,r2
;;;228       		if (++rx_counter1 == RX_BUFFER_SIZE1)
000220  898a              LDRH     r2,[r1,#0xc]
000222  2803              CMP      r0,#3                 ;205
000224  f1020201          ADD      r2,r2,#1
000228  b294              UXTH     r4,r2
00022a  f04f0200          MOV      r2,#0                 ;227
00022e  d01c              BEQ      |L1.618|
;;;229          		{
;;;230          		rx_counter1=0;
;;;231          		rx_buffer_overflow1=1;
;;;232          		}
;;;233    
;;;234    
;;;235    		}
;;;236    
;;;237      	}
;;;238    else if ( IIRValue == IIR_RDA )	/* Receive Data Available */
000230  2802              CMP      r0,#2
000232  d031              BEQ      |L1.664|
;;;239      	{
;;;240    	
;;;241    	//plazma_uart1++;
;;;242    	data=LPC_UART1->RBR;
;;;243    	rx_buffer1[rx_wr_index1]=data;
;;;244       	bRXIN1=1;
;;;245    
;;;246       	if (++rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
;;;247       	if (++rx_counter1 == RX_BUFFER_SIZE1)
;;;248          	{
;;;249          	rx_counter1=0;
;;;250          	rx_buffer_overflow1=1;
;;;251          	}
;;;252    	//modbus_rx_buffer[modbus_rx_buffer_ptr]=data;
;;;253    	//modbus_rx_buffer_ptr++;
;;;254    //	modbus_timeout_cnt=0;
;;;255    
;;;256      	}
;;;257    else if ( IIRValue == IIR_CTI )	/* Character timeout indicator */
000234  2806              CMP      r0,#6
000236  d03e              BEQ      |L1.694|
;;;258      	{
;;;259    	/* Character Time-out indicator */
;;;260    	UART1Status |= 0x100;		/* Bit 9 as the CTI error */
;;;261      	}
;;;262    else if ( IIRValue == IIR_THRE )	/* THRE, transmit holding register empty */
000238  2801              CMP      r0,#1
00023a  d114              BNE      |L1.614|
;;;263      	{
;;;264    	/* THRE interrupt */
;;;265    	
;;;266    	LSRValue = LPC_UART1->LSR;		/* Check status in the LSR to see if
00023c  7d30              LDRB     r0,[r6,#0x14]
;;;267    									valid data in U0THR or not */
;;;268    	if ( LSRValue & LSR_THRE )
00023e  0680              LSLS     r0,r0,#26
000240  d544              BPL      |L1.716|
;;;269    		{
;;;270    	  	UART1TxEmpty = 1;
000242  700f              STRB     r7,[r1,#0]
;;;271    		if (tx_counter1)
000244  8a48              LDRH     r0,[r1,#0x12]  ; tx_counter1
000246  b3a8              CBZ      r0,|L1.692|
;;;272       			{
;;;273       			--tx_counter1;
000248  f1a00001          SUB      r0,r0,#1
00024c  8248              STRH     r0,[r1,#0x12]
;;;274       			LPC_UART1->THR=tx_buffer1[tx_rd_index1];
00024e  4b6e              LDR      r3,|L1.1032|
000250  8a08              LDRH     r0,[r1,#0x10]  ; tx_rd_index1
000252  5c1b              LDRB     r3,[r3,r0]
000254  7033              STRB     r3,[r6,#0]
;;;275       			if (++tx_rd_index1 == TX_BUFFER_SIZE1) tx_rd_index1=0;
000256  f1000001          ADD      r0,r0,#1
00025a  b280              UXTH     r0,r0
00025c  8208              STRH     r0,[r1,#0x10]
00025e  f5b07f96          CMP      r0,#0x12c
000262  d100              BNE      |L1.614|
000264  820a              STRH     r2,[r1,#0x10]
                  |L1.614|
;;;276       			}
;;;277    		else LPC_GPIO2->FIOPIN&=~(1UL<<2);
;;;278    		}
;;;279    	else
;;;280    		{
;;;281    	  	UART1TxEmpty = 0;
;;;282    		}
;;;283      	}
;;;284    }
000266  e8bd81f0          POP      {r4-r8,pc}
                  |L1.618|
00026a  7d30              LDRB     r0,[r6,#0x14]         ;207
00026c  f0100f9e          TST      r0,#0x9e              ;212
000270  d002              BEQ      |L1.632|
000272  6148              STR      r0,[r1,#0x14]         ;216  ; UART1Status
000274  7830              LDRB     r0,[r6,#0]            ;217
000276  e7f6              B        |L1.614|
                  |L1.632|
000278  07c0              LSLS     r0,r0,#31             ;221
00027a  d0f4              BEQ      |L1.614|
00027c  7830              LDRB     r0,[r6,#0]            ;224
00027e  f80c0005          STRB     r0,[r12,r5]           ;225
000282  708f              STRB     r7,[r1,#2]            ;226
000284  810b              STRH     r3,[r1,#8]            ;227
000286  2b64              CMP      r3,#0x64              ;227
000288  d100              BNE      |L1.652|
00028a  810a              STRH     r2,[r1,#8]            ;227
                  |L1.652|
00028c  818c              STRH     r4,[r1,#0xc]          ;228
00028e  2c64              CMP      r4,#0x64              ;228
000290  d1e9              BNE      |L1.614|
000292  818a              STRH     r2,[r1,#0xc]          ;230
000294  70cf              STRB     r7,[r1,#3]            ;231
000296  e7e6              B        |L1.614|
                  |L1.664|
000298  7830              LDRB     r0,[r6,#0]            ;242
00029a  f80c0005          STRB     r0,[r12,r5]           ;243
00029e  708f              STRB     r7,[r1,#2]            ;244
0002a0  810b              STRH     r3,[r1,#8]            ;246
0002a2  2b64              CMP      r3,#0x64              ;246
0002a4  d100              BNE      |L1.680|
0002a6  810a              STRH     r2,[r1,#8]            ;246
                  |L1.680|
0002a8  818c              STRH     r4,[r1,#0xc]          ;247
0002aa  2c64              CMP      r4,#0x64              ;247
0002ac  d1db              BNE      |L1.614|
0002ae  818a              STRH     r2,[r1,#0xc]          ;249
0002b0  70cf              STRB     r7,[r1,#3]            ;250
0002b2  e7d8              B        |L1.614|
                  |L1.692|
0002b4  e004              B        |L1.704|
                  |L1.694|
0002b6  6948              LDR      r0,[r1,#0x14]         ;260  ; UART1Status
0002b8  f4407080          ORR      r0,r0,#0x100          ;260
0002bc  6148              STR      r0,[r1,#0x14]         ;260  ; UART1Status
0002be  e7d2              B        |L1.614|
                  |L1.704|
0002c0  4850              LDR      r0,|L1.1028|
0002c2  6d41              LDR      r1,[r0,#0x54]         ;277
0002c4  f0210104          BIC      r1,r1,#4              ;277
0002c8  6541              STR      r1,[r0,#0x54]         ;277
0002ca  e7cc              B        |L1.614|
                  |L1.716|
0002cc  700a              STRB     r2,[r1,#0]            ;281
0002ce  e7ca              B        |L1.614|
;;;285     
                          ENDP

                  uart_in_an1 PROC
;;;287    //-----------------------------------------------
;;;288    void uart_in_an1(void)
0002d0  b5fe              PUSH     {r1-r7,lr}
;;;289    {
;;;290    char i;
;;;291    //motor_ind[0]^=0b0001000;
;;;292    plazma_suz[0]++;
0002d2  4949              LDR      r1,|L1.1016|
0002d4  3118              ADDS     r1,r1,#0x18
0002d6  7808              LDRB     r0,[r1,#0]  ; plazma_suz
0002d8  f1000001          ADD      r0,r0,#1
0002dc  7008              STRB     r0,[r1,#0]
;;;293    
;;;294    if(UIB1[1]!=0x51)
0002de  4c4a              LDR      r4,|L1.1032|
0002e0  f1a40478          SUB      r4,r4,#0x78
0002e4  7863              LDRB     r3,[r4,#1]  ; UIB1
0002e6  2b51              CMP      r3,#0x51
0002e8  d00a              BEQ      |L1.768|
;;;295    {
;;;296    for(i=0;i<24;i++)
0002ea  f04f0000          MOV      r0,#0
;;;297    	{
;;;298    	UIB10[i]=UIB1[i];
0002ee  f50471d7          ADD      r1,r4,#0x1ae
                  |L1.754|
0002f2  5c22              LDRB     r2,[r4,r0]
0002f4  540a              STRB     r2,[r1,r0]
0002f6  f1000001          ADD      r0,r0,#1              ;296
0002fa  b2c0              UXTB     r0,r0                 ;296
0002fc  2818              CMP      r0,#0x18              ;296
0002fe  d3f8              BCC      |L1.754|
                  |L1.768|
;;;299    	}
;;;300    }
;;;301    uart1_mess[0]++;
000300  4845              LDR      r0,|L1.1048|
000302  7801              LDRB     r1,[r0,#0]  ; uart1_mess
000304  f1010101          ADD      r1,r1,#1
000308  7001              STRB     r1,[r0,#0]
;;;302    
;;;303    if((UIB1[0]==4)&&(UIB1[1]==0)&&(UIB1[2]==2)&&(UIB1[3]==0)&&(UIB1[4]==1) && (ICA_EN==0))
00030a  7820              LDRB     r0,[r4,#0]  ; UIB1
;;;304    	{
;;;305    	
;;;306    	uart_out1(5,4,1,2,(char)bps_I,(char)(bps_I/256),0);
;;;307    	plazma_uart1++;
00030c  4d3a              LDR      r5,|L1.1016|
00030e  4f43              LDR      r7,|L1.1052|
000310  f04f0600          MOV      r6,#0                 ;296
000314  2804              CMP      r0,#4                 ;303
000316  d120              BNE      |L1.858|
000318  b9fb              CBNZ     r3,|L1.858|
00031a  78a0              LDRB     r0,[r4,#2]            ;303  ; UIB1
00031c  2802              CMP      r0,#2                 ;303
00031e  d11c              BNE      |L1.858|
000320  78e0              LDRB     r0,[r4,#3]            ;303  ; UIB1
000322  b9d0              CBNZ     r0,|L1.858|
000324  7920              LDRB     r0,[r4,#4]            ;303  ; UIB1
000326  2801              CMP      r0,#1                 ;303
000328  d117              BNE      |L1.858|
00032a  8838              LDRH     r0,[r7,#0]            ;303  ; ICA_EN
00032c  b9a8              CBNZ     r0,|L1.858|
00032e  483c              LDR      r0,|L1.1056|
000330  2302              MOVS     r3,#2                 ;306
000332  2201              MOVS     r2,#1                 ;306
000334  f9b00000          LDRSH    r0,[r0,#0]            ;306  ; bps_I
000338  17c1              ASRS     r1,r0,#31             ;306
00033a  eb006111          ADD      r1,r0,r1,LSR #24      ;306
00033e  f3c12107          UBFX     r1,r1,#8,#8           ;306
000342  b2c0              UXTB     r0,r0                 ;306
000344  e88d0043          STM      sp,{r0,r1,r6}         ;306
000348  2104              MOVS     r1,#4                 ;306
00034a  2005              MOVS     r0,#5                 ;306
00034c  f7fffffe          BL       uart_out1
000350  7928              LDRB     r0,[r5,#4]  ; plazma_uart1
000352  f1000001          ADD      r0,r0,#1
000356  7128              STRB     r0,[r5,#4]
;;;308    
;;;309    	uart1_net_cnt=0;
000358  706e              STRB     r6,[r5,#1]
                  |L1.858|
;;;310    	}
;;;311    
;;;312    
;;;313    if((UIB1[0]==6)&&(UIB1[1]==0)&&(UIB1[2]==100) && (ICA_EN==0))
00035a  7820              LDRB     r0,[r4,#0]  ; UIB1
00035c  2806              CMP      r0,#6
00035e  d106              BNE      |L1.878|
000360  7861              LDRB     r1,[r4,#1]  ; UIB1
000362  b921              CBNZ     r1,|L1.878|
000364  78a1              LDRB     r1,[r4,#2]  ; UIB1
000366  2964              CMP      r1,#0x64
000368  d101              BNE      |L1.878|
00036a  8839              LDRH     r1,[r7,#0]  ; ICA_EN
00036c  b111              CBZ      r1,|L1.884|
                  |L1.878|
;;;314    	{
;;;315    	short tempSSSS;
;;;316    	tempSSSS=(short)UIB1[4] + ((short)UIB1[3])*256;
;;;317    
;;;318    	plazma_ica2=tempSSSS;
;;;319    
;;;320    	if(tempSSSS&0x4000)
;;;321    		{
;;;322    		tempSSSS&=0x3fff;
;;;323    		if((tempSSSS>0)&&(tempSSSS<5))tempSSSS=0;
;;;324    		else if(tempSSSS>=60)tempSSSS=60;
;;;325    		if(TBAT!=tempSSSS)lc640_write_int(EE_TBAT,tempSSSS);
;;;326    
;;;327    		main_kb_cnt=(tempSSSS*60)-20;
;;;328    		}
;;;329    	else ica_cntrl_hndl=tempSSSS;
;;;330    
;;;331    	ica_cntrl_hndl_cnt=200;
;;;332    
;;;333    	uart1_net_cnt=0;
;;;334    	}
;;;335    
;;;336    
;;;337    else if((UIB1[0]==4)&&(UIB1[1]==1)&&(UIB1[2]==2) && (ICA_EN==1) && (ICA_CH==2) )
00036e  2804              CMP      r0,#4
000370  d030              BEQ      |L1.980|
000372  e03c              B        |L1.1006|
                  |L1.884|
000374  7920              LDRB     r0,[r4,#4]            ;316  ; UIB1
000376  78e1              LDRB     r1,[r4,#3]            ;316  ; UIB1
000378  eb002001          ADD      r0,r0,r1,LSL #8       ;316
00037c  b200              SXTH     r0,r0                 ;316
00037e  4929              LDR      r1,|L1.1060|
000380  8008              STRH     r0,[r1,#0]            ;318
000382  0441              LSLS     r1,r0,#17             ;320
000384  d51e              BPL      |L1.964|
000386  f3c0040d          UBFX     r4,r0,#0,#14          ;322
00038a  f1a40001          SUB      r0,r4,#1              ;323
00038e  2804              CMP      r0,#4                 ;323
000390  d202              BCS      |L1.920|
000392  f04f0400          MOV      r4,#0                 ;323
000396  e003              B        |L1.928|
                  |L1.920|
000398  2c3c              CMP      r4,#0x3c              ;324
00039a  db01              BLT      |L1.928|
00039c  f04f043c          MOV      r4,#0x3c              ;324
                  |L1.928|
0003a0  4821              LDR      r0,|L1.1064|
0003a2  f9b00000          LDRSH    r0,[r0,#0]            ;325  ; TBAT
0003a6  42a0              CMP      r0,r4                 ;325
0003a8  d003              BEQ      |L1.946|
0003aa  4621              MOV      r1,r4                 ;325
0003ac  20c2              MOVS     r0,#0xc2              ;325
0003ae  f7fffffe          BL       lc640_write_int
                  |L1.946|
0003b2  ebc41004          RSB      r0,r4,r4,LSL #4       ;327
0003b6  f06f0113          MVN      r1,#0x13              ;327
0003ba  eb010080          ADD      r0,r1,r0,LSL #2       ;327
0003be  491b              LDR      r1,|L1.1068|
0003c0  8008              STRH     r0,[r1,#0]            ;327
0003c2  e001              B        |L1.968|
                  |L1.964|
0003c4  491a              LDR      r1,|L1.1072|
0003c6  8008              STRH     r0,[r1,#0]            ;329
                  |L1.968|
0003c8  491a              LDR      r1,|L1.1076|
0003ca  f04f00c8          MOV      r0,#0xc8              ;331
0003ce  8008              STRH     r0,[r1,#0]            ;331
0003d0  706e              STRB     r6,[r5,#1]            ;333
                  |L1.978|
;;;338    	{
;;;339    	
;;;340    	ica_your_current=(short)UIB1[3]+((short)UIB1[4]*256);
;;;341    
;;;342    	uart1_net_cnt=0;
;;;343    	}
;;;344    else if((UIB1[0]==CMND)&&(UIB1[1]==1))
;;;345    	{
;;;346    //	adc_buff_out_[0]=UIB1[2]+(UIB1[3]*256);
;;;347    //	adc_buff_out_[1]=UIB1[4]+(UIB1[5]*256);
;;;348    	}
;;;349    
;;;350    else if((UIB1[0]==CMND)&&(UIB1[1]==2))
;;;351    	{
;;;352    //	adc_buff_out_[2]=UIB1[2]+(UIB1[3]*256);
;;;353    //	in_stat_out[0]=UIB1[4];
;;;354    //	in_stat_out[1]=UIB1[5];
;;;355    	}
;;;356    	
;;;357    			
;;;358    }
0003d2  bdfe              POP      {r1-r7,pc}
                  |L1.980|
0003d4  7861              LDRB     r1,[r4,#1]            ;337  ; UIB1
0003d6  2901              CMP      r1,#1                 ;337
0003d8  d109              BNE      |L1.1006|
0003da  78a1              LDRB     r1,[r4,#2]            ;337  ; UIB1
0003dc  2902              CMP      r1,#2                 ;337
0003de  d106              BNE      |L1.1006|
0003e0  8839              LDRH     r1,[r7,#0]            ;337  ; ICA_EN
0003e2  2901              CMP      r1,#1                 ;337
0003e4  d103              BNE      |L1.1006|
0003e6  4914              LDR      r1,|L1.1080|
0003e8  8809              LDRH     r1,[r1,#0]            ;337  ; ICA_CH
0003ea  2902              CMP      r1,#2                 ;337
0003ec  d026              BEQ      |L1.1084|
                  |L1.1006|
0003ee  2816              CMP      r0,#0x16              ;344
0003f0  d1ef              BNE      |L1.978|
0003f2  7860              LDRB     r0,[r4,#1]            ;344  ; UIB1
0003f4  2801              CMP      r0,#1                 ;344
0003f6  bdfe              POP      {r1-r7,pc}
                  |L1.1016|
                          DCD      ||.data||
                  |L1.1020|
                          DCD      0x40010000
                  |L1.1024|
                          DCD      0x4002c000
                  |L1.1028|
                          DCD      0x2009c000
                  |L1.1032|
                          DCD      ||.bss||+0x78
                  |L1.1036|
                          DCD      0x400fc1a8
                  |L1.1040|
                          DCD      SystemFrequency
                  |L1.1044|
                          DCD      0xe000e100
                  |L1.1048|
                          DCD      ||.bss||+0x1a4
                  |L1.1052|
                          DCD      ICA_EN
                  |L1.1056|
                          DCD      bps_I
                  |L1.1060|
                          DCD      plazma_ica2
                  |L1.1064|
                          DCD      TBAT
                  |L1.1068|
                          DCD      main_kb_cnt
                  |L1.1072|
                          DCD      ica_cntrl_hndl
                  |L1.1076|
                          DCD      ica_cntrl_hndl_cnt
                  |L1.1080|
                          DCD      ICA_CH
                  |L1.1084|
00043c  78e0              LDRB     r0,[r4,#3]            ;340  ; UIB1
00043e  7921              LDRB     r1,[r4,#4]            ;340  ; UIB1
000440  eb002001          ADD      r0,r0,r1,LSL #8       ;340
000444  4945              LDR      r1,|L1.1372|
000446  8008              STRH     r0,[r1,#0]            ;340
000448  706e              STRB     r6,[r5,#1]            ;342
00044a  bdfe              POP      {r1-r7,pc}
;;;359     
                          ENDP

                  index_offset1 PROC
;;;360    //-----------------------------------------------
;;;361    char index_offset1 (signed char index,signed char offset)
00044c  4408              ADD      r0,r0,r1
;;;362    {
;;;363    index=index+offset;
00044e  b240              SXTB     r0,r0
;;;364    if(index>=RX_BUFFER_SIZE1) index-=RX_BUFFER_SIZE1; 
000450  2864              CMP      r0,#0x64
000452  db02              BLT      |L1.1114|
000454  f1a00064          SUB      r0,r0,#0x64
000458  b240              SXTB     r0,r0
                  |L1.1114|
;;;365    if(index<0) index+=RX_BUFFER_SIZE1;
00045a  2800              CMP      r0,#0
00045c  da02              BGE      |L1.1124|
00045e  f1000064          ADD      r0,r0,#0x64
000462  b240              SXTB     r0,r0
                  |L1.1124|
;;;366    return index;
000464  b2c0              UXTB     r0,r0
;;;367    }
000466  4770              BX       lr
;;;368    
                          ENDP

                  control_check1 PROC
;;;369    //-----------------------------------------------
;;;370    char control_check1(char index)
000468  b570              PUSH     {r4-r6,lr}
;;;371    {
;;;372    char i=0,ii=0,iii;
00046a  f04f0200          MOV      r2,#0
;;;373    
;;;374    if(rx_buffer1[index]!=END) goto error_cc;
00046e  4e3c              LDR      r6,|L1.1376|
000470  5c31              LDRB     r1,[r6,r0]
000472  290a              CMP      r1,#0xa
000474  d120              BNE      |L1.1208|
;;;375    
;;;376    ii=rx_buffer1[index_offset1(index,-2)];
000476  b240              SXTB     r0,r0
000478  1e91              SUBS     r1,r2,#2
00047a  4605              MOV      r5,r0
00047c  f7fffffe          BL       index_offset1
000480  5c34              LDRB     r4,[r6,r0]
;;;377    iii=0;
000482  f04f0300          MOV      r3,#0
;;;378    for(i=0;i<=ii;i++)
000486  e00b              B        |L1.1184|
                  |L1.1160|
;;;379    	{
;;;380    	iii^=rx_buffer1[index_offset1(index,-2-ii+i)];
000488  1b10              SUBS     r0,r2,r4
00048a  1e80              SUBS     r0,r0,#2
00048c  b241              SXTB     r1,r0
00048e  4628              MOV      r0,r5
000490  f7fffffe          BL       index_offset1
000494  5c30              LDRB     r0,[r6,r0]
000496  ea800303          EOR      r3,r0,r3
00049a  f1020201          ADD      r2,r2,#1              ;378
00049e  b2d2              UXTB     r2,r2                 ;378
                  |L1.1184|
0004a0  42a2              CMP      r2,r4                 ;378
0004a2  d9f1              BLS      |L1.1160|
;;;381    	}
;;;382    if (iii!=rx_buffer1[index_offset1(index,-1)]) goto error_cc;	
0004a4  f04f31ff          MOV      r1,#0xffffffff
0004a8  4628              MOV      r0,r5
0004aa  f7fffffe          BL       index_offset1
0004ae  5c30              LDRB     r0,[r6,r0]
0004b0  4298              CMP      r0,r3
0004b2  d101              BNE      |L1.1208|
;;;383    
;;;384    
;;;385    //success_cc:
;;;386    return 1;
0004b4  2001              MOVS     r0,#1
;;;387    //goto end_cc;
;;;388    error_cc:
;;;389    return 0;
;;;390    //goto end_cc;
;;;391    
;;;392    //end_cc:
;;;393    //__nop();
;;;394    }
0004b6  bd70              POP      {r4-r6,pc}
                  |L1.1208|
0004b8  2000              MOVS     r0,#0                 ;389
0004ba  bd70              POP      {r4-r6,pc}
;;;395    
                          ENDP

                  uart_in1 PROC
;;;396    //-----------------------------------------------
;;;397    void uart_in1(void)
0004bc  e92d41f0          PUSH     {r4-r8,lr}
;;;398    {
;;;399    char temp,i/*,count*/;
;;;400    
;;;401    __disable_irq();
0004c0  b672              CPSID    i
;;;402    
;;;403    if(rx_buffer_overflow1)
0004c2  4d28              LDR      r5,|L1.1380|
0004c4  2600              MOVS     r6,#0
0004c6  78e8              LDRB     r0,[r5,#3]  ; rx_buffer_overflow1
0004c8  b118              CBZ      r0,|L1.1234|
;;;404    	{
;;;405    	rx_wr_index1=0;
0004ca  812e              STRH     r6,[r5,#8]
;;;406    	rx_rd_index1=0;
0004cc  816e              STRH     r6,[r5,#0xa]
;;;407    	rx_counter1=0;
0004ce  81ae              STRH     r6,[r5,#0xc]
;;;408    	rx_buffer_overflow1=0;
0004d0  70ee              STRB     r6,[r5,#3]
                  |L1.1234|
;;;409    	}    
;;;410    usart1_router_wrk=1;	
0004d2  f04f0001          MOV      r0,#1
0004d6  71a8              STRB     r0,[r5,#6]
;;;411    if(rx_counter1&&(rx_buffer1[index_offset1(rx_wr_index1,-1)])==END)
0004d8  89a8              LDRH     r0,[r5,#0xc]  ; rx_counter1
0004da  b3e8              CBZ      r0,|L1.1368|
0004dc  8928              LDRH     r0,[r5,#8]  ; rx_wr_index1
0004de  f04f32ff          MOV      r2,#0xffffffff
0004e2  4611              MOV      r1,r2
0004e4  b240              SXTB     r0,r0
0004e6  f7fffffe          BL       index_offset1
0004ea  4f1d              LDR      r7,|L1.1376|
0004ec  5c38              LDRB     r0,[r7,r0]
0004ee  280a              CMP      r0,#0xa
0004f0  d132              BNE      |L1.1368|
;;;412    	{
;;;413    	
;;;414         temp=rx_buffer1[index_offset1(rx_wr_index1,-3)];
0004f2  8928              LDRH     r0,[r5,#8]  ; rx_wr_index1
0004f4  f06f0102          MVN      r1,#2
0004f8  b240              SXTB     r0,r0
0004fa  f7fffffe          BL       index_offset1
0004fe  5c3c              LDRB     r4,[r7,r0]
;;;415        	if(temp<20) 
000500  2c14              CMP      r4,#0x14
000502  d229              BCS      |L1.1368|
;;;416        		{
;;;417        		if(control_check1(index_offset1(rx_wr_index1,-1)))
000504  8928              LDRH     r0,[r5,#8]  ; rx_wr_index1
000506  4611              MOV      r1,r2
000508  b240              SXTB     r0,r0
00050a  f7fffffe          BL       index_offset1
00050e  f7fffffe          BL       control_check1
000512  b308              CBZ      r0,|L1.1368|
;;;418        			{
;;;419        		
;;;420        			rx_rd_index1=index_offset1(rx_wr_index1,-3-temp);
000514  1ce0              ADDS     r0,r4,#3
000516  4240              RSBS     r0,r0,#0
000518  b241              SXTB     r1,r0
00051a  8928              LDRH     r0,[r5,#8]  ; rx_wr_index1
00051c  b240              SXTB     r0,r0
00051e  f7fffffe          BL       index_offset1
000522  8168              STRH     r0,[r5,#0xa]
;;;421        			for(i=0;i<temp;i++)
000524  f04f0200          MOV      r2,#0
;;;422    				{
;;;423    				UIB1[i]=rx_buffer1[index_offset1(rx_rd_index1,i)];
000528  f1a70314          SUB      r3,r7,#0x14
00052c  e009              B        |L1.1346|
                  |L1.1326|
00052e  8968              LDRH     r0,[r5,#0xa]  ; rx_rd_index1
000530  b251              SXTB     r1,r2
000532  b240              SXTB     r0,r0
000534  f7fffffe          BL       index_offset1
000538  5c38              LDRB     r0,[r7,r0]
00053a  5498              STRB     r0,[r3,r2]
00053c  f1020201          ADD      r2,r2,#1              ;421
000540  b2d2              UXTB     r2,r2                 ;421
                  |L1.1346|
000542  42a2              CMP      r2,r4                 ;421
000544  d3f3              BCC      |L1.1326|
;;;424    				} 
;;;425    			rx_rd_index1=rx_wr_index1;
000546  8928              LDRH     r0,[r5,#8]  ; rx_wr_index1
000548  8168              STRH     r0,[r5,#0xa]
;;;426    			rx_counter1=0;
00054a  81ae              STRH     r6,[r5,#0xc]
;;;427    			uart_in_an1();
00054c  f7fffffe          BL       uart_in_an1
;;;428    			
;;;429    			if(usart1_router_stat==ursMEGA)usart1_router_wrk=0;
000550  7968              LDRB     r0,[r5,#5]  ; usart1_router_stat
000552  2855              CMP      r0,#0x55
000554  d100              BNE      |L1.1368|
000556  71ae              STRB     r6,[r5,#6]
                  |L1.1368|
;;;430        			}
;;;431     	
;;;432        		} 
;;;433        	}
;;;434    //rx_read_power_cnt_plazma++;
;;;435    #ifdef CE102M_ENABLED
;;;436    	if(rx_read_power_cnt_phase==1)
;;;437    		{
;;;438    		
;;;439    		if((rx_buffer1[rx_wr_index1-1]==0x0a)/*&&(rx_buffer1[6]==0xc5)*/)
;;;440    			{
;;;441    			rx_read_power_cnt_plazma++;
;;;442    			rx_read_power_cnt_phase=2;
;;;443    			ce102m_delayCnt=200;
;;;444    			}
;;;445    		}
;;;446    else if(rx_read_power_cnt_phase==3)
;;;447    		{
;;;448    		
;;;449    		if(/*(rx_buffer1[6]==0x81)&&*/(rx_buffer1[rx_wr_index1-2]==0x03))
;;;450    			{
;;;451    			rx_read_power_cnt_plazma++;
;;;452    			if(bENERGOMETR_UIP==0) rx_read_power_cnt_phase=4;
;;;453    			else if(bENERGOMETR_UIP==1) rx_read_power_cnt_phase=8;
;;;454    			else rx_read_power_cnt_phase=20;
;;;455    			ce102m_delayCnt=200;
;;;456    			}
;;;457    		}
;;;458    else if((rx_read_power_cnt_phase==5)&&(rx_wr_index1>10))
;;;459    		{
;;;460    		
;;;461    		if(((rx_buffer1[rx_wr_index1-1])&0x7f)=='(')
;;;462    			{
;;;463    			rx_read_power_cnt_plazma++;
;;;464    			rx_read_power_cnt_phase=6;
;;;465    			ce102m_delayCnt=200;
;;;466    			rx_wr_index1=0;
;;;467    			}
;;;468    		}
;;;469    else if(rx_read_power_cnt_phase==6)
;;;470    		{
;;;471    		char float_buff[20]={0,0,0,0,0,0,0,0,0,0};
;;;472    		char* float_buff_ptr;
;;;473    		float volta;
;;;474    		char i,point_marker;
;;;475    		unsigned short ii;		
;;;476    		float_buff_ptr=float_buff;
;;;477    
;;;478    		if(((rx_buffer1[rx_wr_index1-1])&0x7f)==')')
;;;479    			{
;;;480    			ii=rx_wr_index1-1;
;;;481    			rx_read_power_cnt_plazma=rx_wr_index1-1;
;;;482    			
;;;483    			volta_short=0;//rx_wr_index1-1;
;;;484    			for(i=0;i<ii;i++)
;;;485    				{
;;;486    				float_buff[i]=rx_buffer1[i]&0x7f;
;;;487    				float_buff[i+1]=' ';
;;;488     //volta_short+=(rx_buffer1[ii-i]&0x7f);//-0x30)*pow(10,i);
;;;489     				if(float_buff[i]=='.')point_marker=i;
;;;490    				rx_read_power_cnt_plazma++;
;;;491    				}
;;;492    
;;;493    
;;;494    		///if(((rx_buffer1[rx_wr_index1-2])&0x7f)=='.')
;;;495    		///	{
;;;496    		//	char s [] = "1.23";
;;;497    		///	ii=rx_wr_index1-1;
;;;498    		///	rx_read_power_cnt_plazma++;
;;;499    			rx_read_power_cnt_phase=15;
;;;500    			ce102m_delayCnt=200;
;;;501    			//memcpy(float_buff,rx_buffer1,rx_wr_index1-1);
;;;502    		///	volta_short=0;//rx_wr_index1-1;
;;;503    		///	for(i=0;i<ii;i++)
;;;504    				{
;;;505    		///		float_buff[i]=rx_buffer1[i]&0x7f;
;;;506    		///		float_buff[i+1]=' ';
;;;507    				/*if(rx_buffer1[ii-i]=='(')break;
;;;508    				else*/ //volta_short+=(rx_buffer1[ii-i]&0x7f);//-0x30)*pow(10,i);
;;;509    				}
;;;510    			//float_buff[0]='2';
;;;511    			//float_buff[1]='3';
;;;512    			//float_buff[2]='4';
;;;513    			//float_buff[3]='.';
;;;514    			//float_buff[4]='5';
;;;515    			//uart_out__adr1(float_buff, 10);
;;;516    			//volta=atof(s);//atof(float_buff);
;;;517    			volta_short=((atoi(float_buff))*10)+ ((atoi(&float_buff[point_marker+1]))/10);
;;;518    			}
;;;519    		}
;;;520    else if(rx_read_power_cnt_phase==7)
;;;521    		{
;;;522    
;;;523    
;;;524    		if(((rx_buffer1[rx_wr_index1-1])&0x7f)==')')
;;;525    			{
;;;526    			rx_read_power_cnt_phase=18;
;;;527    			rx_wr_index1=0;	
;;;528    			ce102m_delayCnt=200;
;;;529    			}
;;;530    		}
;;;531    else if((rx_read_power_cnt_phase==9)&&(rx_wr_index1>15))
;;;532    		{
;;;533    		
;;;534    		if(((rx_buffer1[rx_wr_index1-1])&0x7f)=='(')
;;;535    			{
;;;536    			rx_read_power_cnt_plazma++;
;;;537    			rx_read_power_cnt_phase=10;
;;;538    			
;;;539    			rx_wr_index1=0;
;;;540    			}
;;;541    		}
;;;542    else if((rx_read_power_cnt_phase==10)/*&&(rx_wr_index1>2)*/)
;;;543    		{
;;;544    		char float_buff[20]={0,0,0,0,0,0,0,0,0,0};
;;;545    		char* float_buff_ptr;
;;;546    		float curr;
;;;547    		char i,point_marker;
;;;548    		unsigned short ii;
;;;549    		int curr_1,curr_2;		
;;;550    		float_buff_ptr=float_buff;
;;;551    
;;;552    
;;;553    		if(((rx_buffer1[rx_wr_index1-1])&0x7f)==')')
;;;554    			{
;;;555    		//	char s [] = "1.23";
;;;556    			ii=rx_wr_index1-1;
;;;557    			rx_read_power_cnt_plazma=rx_wr_index1-1;
;;;558    			
;;;559    			//ce102m_delayCnt=500;
;;;560    			//memcpy(float_buff,rx_buffer1,rx_wr_index1-1);
;;;561    			curr_short=0;//rx_wr_index1-1;
;;;562    			for(i=0;i<ii;i++)
;;;563    				{
;;;564    				float_buff[i]=rx_buffer1[i]&0x7f;
;;;565    				float_buff[i+1]=' ';
;;;566     //volta_short+=(rx_buffer1[ii-i]&0x7f);//-0x30)*pow(10,i);
;;;567     				if(float_buff[i]=='.')point_marker=i;
;;;568    				rx_read_power_cnt_plazma++;
;;;569    				}
;;;570    			curr_short=ii;
;;;571    			/*float_buff[0]='2';
;;;572    			float_buff[1]='.';
;;;573    			float_buff[2]='4';
;;;574    			float_buff[3]='3';
;;;575    			float_buff[4]='5';*/
;;;576    			curr_1=atoi(float_buff);
;;;577    			curr_2=atoi(&float_buff[point_marker+1]);
;;;578    			curr_short=(curr_2/10)+(curr_1*100);
;;;579    			//curr=0.0;
;;;580    			//uart_out__adr1(float_buff, 6);
;;;581    			//curr=atof(float_buff);
;;;582    			//curr=0.354;
;;;583    			//uart_out__adr1((char*)&curr, 10);
;;;584    			//curr*=1000.0;
;;;585    			//(int)(curr);//volta;
;;;586    			rx_read_power_cnt_phase=17;
;;;587    			}
;;;588    		}
;;;589    
;;;590    else if((rx_read_power_cnt_phase==21)&&(rx_wr_index1>10))
;;;591    		{
;;;592    		
;;;593    		if(((rx_buffer1[rx_wr_index1-1])&0x7f)=='(')
;;;594    			{
;;;595    			rx_read_power_cnt_plazma++;
;;;596    			rx_read_power_cnt_phase=22;
;;;597    			
;;;598    			//rx_read_power_cnt_plazma=rx_wr_index1;
;;;599    			rx_wr_index1=0;
;;;600    
;;;601    			}
;;;602    		}
;;;603    else if((rx_read_power_cnt_phase==22)&&(rx_wr_index1>2))
;;;604    		{
;;;605    		char float_buff[20]={0,0,0,0,0,0,0,0,0,0};
;;;606    		char* float_buff_ptr;
;;;607    		float power;
;;;608    		char i,point_marker;
;;;609    		unsigned short ii;
;;;610    		int power_1,power_2;		
;;;611    		float_buff_ptr=float_buff;
;;;612    
;;;613    
;;;614    		if(((rx_buffer1[rx_wr_index1-1])&0x7f)==')')
;;;615    			{
;;;616    		//	char s [] = "1.23";
;;;617    			ii=rx_wr_index1-1;
;;;618    			rx_read_power_cnt_plazma=rx_wr_index1-1;
;;;619    			
;;;620    			//ce102m_delayCnt=500;
;;;621    			//memcpy(float_buff,rx_buffer1,rx_wr_index1-1);
;;;622    			power_int=0;//rx_wr_index1-1;
;;;623    			for(i=0;i<ii;i++)
;;;624    				{
;;;625    				float_buff[i]=rx_buffer1[i]&0x7f;
;;;626    				float_buff[i+1]=' ';
;;;627     //volta_short+=(rx_buffer1[ii-i]&0x7f);//-0x30)*pow(10,i);
;;;628     				if(float_buff[i]=='.')
;;;629    					{
;;;630    					point_marker=i;
;;;631    					//float_buff[i-1]='5';
;;;632    					}
;;;633    				rx_read_power_cnt_plazma++;
;;;634    				//if((point_marker!=0)&&(i==(point_marker+3)))break;
;;;635    				}
;;;636    			power_int=ii;
;;;637    			/*float_buff[0]='2';
;;;638    			float_buff[1]='.';
;;;639    			float_buff[2]='4';
;;;640    			float_buff[3]='3';
;;;641    			float_buff[4]='5';*/
;;;642    			power_1=atoi(float_buff);
;;;643    			power_2=(atoi(&float_buff[point_marker+1]))/1000;
;;;644    			power_int=power_2+(power_1*1000);
;;;645    			//power_int=power_2;
;;;646    			//curr=0.0;
;;;647    			//float_buff[0]=rx_wr_index1;
;;;648    			//uart_out__adr1(float_buff, 5);
;;;649    			//curr=atof(float_buff);
;;;650    			//curr=0.354;
;;;651    			//uart_out__adr1((char*)&curr, 10);
;;;652    			//curr*=1000.0;
;;;653    			//(int)(curr);//volta;
;;;654    			rx_read_power_cnt_phase=16;
;;;655    			}
;;;656    		}
;;;657    
;;;658    #endif	
;;;659    
;;;660    
;;;661    __enable_irq();     
000558  b662              CPSIE    i
;;;662    }   	
00055a  e684              B        |L1.614|
;;;663    
                          ENDP

                  |L1.1372|
                          DCD      ica_your_current
                  |L1.1376|
                          DCD      ||.bss||+0x14
                  |L1.1380|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UIB1
                          %        20
                  rx_buffer1
                          %        100
                  tx_buffer1
                          %        300
                  uart1_mess
                          %        10
                  UIB10
                          %        30

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.4||, ||.bss||
                  data_rs1
                          %        40

                          AREA ||area_number.5||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.5||, ||.bss||
                  memo_out1
                          %        100

                          AREA ||.data||, DATA, ALIGN=2

                  UART1TxEmpty
000000  01                DCB      0x01
                  uart1_net_cnt
000001  00                DCB      0x00
                  bRXIN1
000002  00                DCB      0x00
                  rx_buffer_overflow1
000003  00                DCB      0x00
                  plazma_uart1
000004  00                DCB      0x00
                  usart1_router_stat
000005  00                DCB      0x00
                  usart1_router_wrk
000006  0000              DCB      0x00,0x00
                  rx_wr_index1
000008  0000              DCB      0x00,0x00
                  rx_rd_index1
00000a  0000              DCB      0x00,0x00
                  rx_counter1
00000c  0000              DCB      0x00,0x00
                  tx_wr_index1
00000e  0000              DCB      0x00,0x00
                  tx_rd_index1
000010  0000              DCB      0x00,0x00
                  tx_counter1
000012  0000              DCB      0x00,0x00
                  UART1Status
                          DCD      0x00000000
                  plazma_suz
                          DCD      0x00000000
00001c  00                DCB      0x00

                          AREA ||area_number.8||, DATA, ALIGN=0

                          EXPORTAS ||area_number.8||, ||.data||
                  flag1
000000  00                DCB      0x00

                          AREA ||area_number.9||, DATA, ALIGN=0

                          EXPORTAS ||area_number.9||, ||.data||
                  usart1_router_cnt
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "uart1.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_uart1_c_4c3c9f65____REV16|
#line 112 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_uart1_c_4c3c9f65____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_uart1_c_4c3c9f65____REVSH|
#line 130
|__asm___7_uart1_c_4c3c9f65____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
