; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\EXE\emac_lpc17xx.o --asm_dir=.\ --list_dir=.\ --depend=.\EXE\emac_lpc17xx.d --feedback=.\EXE\UKU_220_IPS_TERMOKOMPENSAT.fed --cpu=Cortex-M3 --apcs=interwork -O1 -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\NXP\LPC17xx -D__MICROLIB -DUKU_220_IPS_TERMOKOMPENSAT -DUKU2071x --omf_browse=.\EXE\emac_lpc17xx.crf C:\Keil\ARM\Boards\Keil\MCB1700\RL\TCPnet\Library\EMAC_LPC17xx.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  tx_descr_init PROC
;;;324    
;;;325    static void tx_descr_init (void) {
000000  b530              PUSH     {r4,r5,lr}
;;;326      /* Initialize Transmit Descriptor and Status array. */
;;;327      U32 i;
;;;328    
;;;329      for (i = 0; i < NUM_TX_FRAG; i++) {
000002  f04f0000          MOV      r0,#0
;;;330        Tx_Desc[i].Packet = (U32)&tx_buf[i];
000006  4cff              LDR      r4,|L1.1028|
000008  4602              MOV      r2,r0                 ;329
00000a  49ff              LDR      r1,|L1.1032|
;;;331        Tx_Desc[i].Ctrl   = 0;
;;;332        Tx_Stat[i].Info   = 0;
00000c  f1010318          ADD      r3,r1,#0x18
                  |L1.16|
000010  eb000540          ADD      r5,r0,r0,LSL #1       ;330
000014  eb042545          ADD      r5,r4,r5,LSL #9       ;330
000018  f8415030          STR      r5,[r1,r0,LSL #3]     ;330
00001c  eb0105c0          ADD      r5,r1,r0,LSL #3       ;331
000020  606a              STR      r2,[r5,#4]            ;331
000022  f8432020          STR      r2,[r3,r0,LSL #2]
000026  f1000001          ADD      r0,r0,#1              ;329
00002a  2803              CMP      r0,#3                 ;329
00002c  d3f0              BCC      |L1.16|
;;;333      }
;;;334    
;;;335      /* Set EMAC Transmit Descriptor Registers. */
;;;336      LPC_EMAC->TxDescriptor       = (U32)&Tx_Desc[0];
00002e  48f7              LDR      r0,|L1.1036|
000030  6001              STR      r1,[r0,#0]
;;;337      LPC_EMAC->TxStatus           = (U32)&Tx_Stat[0];
000032  6043              STR      r3,[r0,#4]
;;;338      LPC_EMAC->TxDescriptorNumber = NUM_TX_FRAG-1;
000034  f04f0102          MOV      r1,#2
000038  6081              STR      r1,[r0,#8]
;;;339    
;;;340      /* Tx Descriptors Point to 0 */
;;;341      LPC_EMAC->TxProduceIndex  = 0;
00003a  60c2              STR      r2,[r0,#0xc]
;;;342    }
00003c  bd30              POP      {r4,r5,pc}
;;;343    
                          ENDP

                  rx_descr_init PROC
;;;301    
;;;302    static void rx_descr_init (void) {
00003e  b570              PUSH     {r4-r6,lr}
;;;303      /* Initialize Receive Descriptor and Status array. */
;;;304      U32 i;
;;;305    
;;;306      for (i = 0; i < NUM_RX_FRAG; i++) {
000040  f04f0000          MOV      r0,#0
;;;307        Rx_Desc[i].Packet  = (U32)&rx_buf[i];
000044  4cf0              LDR      r4,|L1.1032|
;;;308        Rx_Desc[i].Ctrl    = RCTRL_INT | (ETH_FRAG_SIZE-1);
000046  4df2              LDR      r5,|L1.1040|
000048  f1040424          ADD      r4,r4,#0x24           ;307
00004c  f1a40364          SUB      r3,r4,#0x64           ;307
000050  4601              MOV      r1,r0                 ;306
;;;309        Rx_Stat[i].Info    = 0;
000052  f1030220          ADD      r2,r3,#0x20
                  |L1.86|
000056  eb000640          ADD      r6,r0,r0,LSL #1       ;307
00005a  eb042646          ADD      r6,r4,r6,LSL #9       ;307
00005e  f8436030          STR      r6,[r3,r0,LSL #3]     ;307
000062  eb0306c0          ADD      r6,r3,r0,LSL #3       ;308
000066  6075              STR      r5,[r6,#4]            ;308
000068  f8421030          STR      r1,[r2,r0,LSL #3]
;;;310        Rx_Stat[i].HashCRC = 0;
00006c  eb0206c0          ADD      r6,r2,r0,LSL #3
000070  6071              STR      r1,[r6,#4]
000072  f1000001          ADD      r0,r0,#1              ;306
000076  2804              CMP      r0,#4                 ;306
000078  d3ed              BCC      |L1.86|
;;;311      }
;;;312    
;;;313      /* Set EMAC Receive Descriptor Registers. */
;;;314      LPC_EMAC->RxDescriptor       = (U32)&Rx_Desc[0];
00007a  48e6              LDR      r0,|L1.1044|
00007c  6003              STR      r3,[r0,#0]
;;;315      LPC_EMAC->RxStatus           = (U32)&Rx_Stat[0];
00007e  6042              STR      r2,[r0,#4]
;;;316      LPC_EMAC->RxDescriptorNumber = NUM_RX_FRAG-1;
000080  f04f0203          MOV      r2,#3
000084  6082              STR      r2,[r0,#8]
;;;317    
;;;318      /* Rx Descriptors Point to 0 */
;;;319      LPC_EMAC->RxConsumeIndex  = 0;
000086  6101              STR      r1,[r0,#0x10]
;;;320    }
000088  bd70              POP      {r4-r6,pc}
;;;321    
                          ENDP

                  turnaround_MDIO PROC
;;;367    
;;;368    static void turnaround_MDIO (void) {
00008a  48e3              LDR      r0,|L1.1048|
;;;369      /* Turnaround MDO is tristated. */
;;;370    
;;;371      LPC_GPIO2->FIODIR &= ~MDIO;
00008c  6c01              LDR      r1,[r0,#0x40]
00008e  f4217100          BIC      r1,r1,#0x200
000092  6401              STR      r1,[r0,#0x40]
;;;372      LPC_GPIO2->FIOSET  = MDC;
000094  f44f7180          MOV      r1,#0x100
000098  6581              STR      r1,[r0,#0x58]
;;;373      delay ();
00009a  bf00              NOP      
00009c  bf00              NOP      
00009e  bf00              NOP      
;;;374      LPC_GPIO2->FIOCLR  = MDC;
0000a0  65c1              STR      r1,[r0,#0x5c]
;;;375      delay ();
0000a2  bf00              NOP      
0000a4  bf00              NOP      
0000a6  bf00              NOP      
;;;376    }
0000a8  4770              BX       lr
;;;377    
                          ENDP

                  input_MDIO PROC
;;;379    
;;;380    static U32 input_MDIO (void) {
0000aa  b510              PUSH     {r4,lr}
;;;381      /* Input a value from the MII PHY management interface. */
;;;382      U32 i,val = 0;
0000ac  f04f0000          MOV      r0,#0
;;;383    
;;;384      for (i = 0; i < 16; i++) {
0000b0  4601              MOV      r1,r0
;;;385        val <<= 1;
;;;386        LPC_GPIO2->FIOSET = MDC;
0000b2  4ad9              LDR      r2,|L1.1048|
0000b4  f44f7380          MOV      r3,#0x100
                  |L1.184|
0000b8  ea4f0040          LSL      r0,r0,#1              ;385
0000bc  6593              STR      r3,[r2,#0x58]
;;;387        delay ();
0000be  bf00              NOP      
0000c0  bf00              NOP      
0000c2  bf00              NOP      
;;;388        LPC_GPIO2->FIOCLR = MDC;
0000c4  65d3              STR      r3,[r2,#0x5c]
;;;389        if (LPC_GPIO2->FIOPIN & MDIO) {
0000c6  6d54              LDR      r4,[r2,#0x54]
0000c8  05a4              LSLS     r4,r4,#22
0000ca  d501              BPL      |L1.208|
;;;390          val |= 1;
0000cc  f0400001          ORR      r0,r0,#1
                  |L1.208|
0000d0  f1010101          ADD      r1,r1,#1              ;384
0000d4  2910              CMP      r1,#0x10              ;384
0000d6  d3ef              BCC      |L1.184|
;;;391        }
;;;392      }
;;;393      return (val);
;;;394    }
0000d8  bd10              POP      {r4,pc}
;;;395    
                          ENDP

                  output_MDIO PROC
;;;348    
;;;349    static void output_MDIO (U32 val, U32 n) {
0000da  b510              PUSH     {r4,lr}
;;;350      /* Output a value to the MII PHY management interface. */
;;;351    
;;;352      for (val <<= (32 - n); n; val <<= 1, n--) {
0000dc  f1c10220          RSB      r2,r1,#0x20
0000e0  fa00f002          LSL      r0,r0,r2
;;;353        if (val & 0x80000000) {
;;;354          LPC_GPIO2->FIOSET = MDIO;
0000e4  f44f7300          MOV      r3,#0x200
0000e8  4acb              LDR      r2,|L1.1048|
;;;355        }
;;;356        else {
;;;357          LPC_GPIO2->FIOCLR = MDIO;
;;;358        }
;;;359        delay ();
;;;360        LPC_GPIO2->FIOSET = MDC;
0000ea  f44f7480          MOV      r4,#0x100
0000ee  e010              B        |L1.274|
                  |L1.240|
0000f0  2800              CMP      r0,#0                 ;353
0000f2  da01              BGE      |L1.248|
0000f4  6593              STR      r3,[r2,#0x58]         ;354
0000f6  e000              B        |L1.250|
                  |L1.248|
0000f8  65d3              STR      r3,[r2,#0x5c]         ;357
                  |L1.250|
0000fa  bf00              NOP                            ;359
0000fc  bf00              NOP                            ;359
0000fe  bf00              NOP                            ;359
000100  6594              STR      r4,[r2,#0x58]
;;;361        delay ();
000102  bf00              NOP      
000104  bf00              NOP      
000106  bf00              NOP      
;;;362        LPC_GPIO2->FIOCLR = MDC;
000108  65d4              STR      r4,[r2,#0x5c]
00010a  ea4f0040          LSL      r0,r0,#1              ;352
00010e  f1a10101          SUB      r1,r1,#1              ;352
                  |L1.274|
000112  2900              CMP      r1,#0                 ;352
000114  d1ec              BNE      |L1.240|
;;;363      }
;;;364    }
000116  bd10              POP      {r4,pc}
;;;365    
                          ENDP

                  read_PHY PROC
;;;445    
;;;446    static U16 read_PHY (U32 PhyReg) {
000118  b510              PUSH     {r4,lr}
00011a  4604              MOV      r4,r0
;;;447      /* Read a PHY register 'PhyReg'. */
;;;448      U32 tout, val;
;;;449    
;;;450      if (dev_175x == __TRUE) {
00011c  48bf              LDR      r0,|L1.1052|
00011e  7800              LDRB     r0,[r0,#0]  ; dev_175x
000120  2801              CMP      r0,#1
000122  d018              BEQ      |L1.342|
;;;451        /* Software MII Management for LPC175x. */
;;;452        /* Remapped MDC on P2.8 and MDIO on P2.9 does not work. */
;;;453        LPC_GPIO2->FIODIR |= MDIO;
;;;454    
;;;455        /* 32 consecutive ones on MDO to establish sync */
;;;456        output_MDIO (0xFFFFFFFF, 32);
;;;457    
;;;458        /* start code (01), read command (10) */
;;;459        output_MDIO (0x06, 4);
;;;460    
;;;461        /* write PHY address */
;;;462        output_MDIO (DP83848C_DEF_ADR >> 8, 5);
;;;463    
;;;464        /* write the PHY register to write */
;;;465        output_MDIO (PhyReg, 5);
;;;466    
;;;467        /* turnaround MDO is tristated */
;;;468        turnaround_MDIO ();
;;;469    
;;;470        /* read the data value */
;;;471        val = input_MDIO ();
;;;472    
;;;473        /* turnaround MDIO is tristated */
;;;474        turnaround_MDIO ();
;;;475      }
;;;476      else {
;;;477        LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
000124  f04f41a0          MOV      r1,#0x50000000
000128  f4447080          ORR      r0,r4,#0x100
00012c  6288              STR      r0,[r1,#0x28]
;;;478        LPC_EMAC->MCMD = MCMD_READ;
00012e  f04f0001          MOV      r0,#1
000132  6248              STR      r0,[r1,#0x24]
;;;479    
;;;480        /* Wait until operation completed */
;;;481        for (tout = 0; tout < MII_RD_TOUT; tout++) {
000134  f04f0000          MOV      r0,#0
000138  f44f23a0          MOV      r3,#0x50000
                  |L1.316|
;;;482          if ((LPC_EMAC->MIND & MIND_BUSY) == 0) {
00013c  6b4a              LDR      r2,[r1,#0x34]
00013e  07d2              LSLS     r2,r2,#31
000140  d003              BEQ      |L1.330|
000142  f1000001          ADD      r0,r0,#1              ;481
000146  4298              CMP      r0,r3                 ;481
000148  d3f8              BCC      |L1.316|
                  |L1.330|
;;;483            break;
;;;484          }
;;;485        }
;;;486        LPC_EMAC->MCMD = 0;
00014a  f04f0000          MOV      r0,#0
00014e  6248              STR      r0,[r1,#0x24]
;;;487        val = LPC_EMAC->MRDD;
000150  6b0c              LDR      r4,[r1,#0x30]
                  |L1.338|
;;;488      }
;;;489      return (val);
000152  b2a0              UXTH     r0,r4
;;;490    }
000154  bd10              POP      {r4,pc}
                  |L1.342|
000156  48b0              LDR      r0,|L1.1048|
000158  6c01              LDR      r1,[r0,#0x40]         ;453
00015a  f4417100          ORR      r1,r1,#0x200          ;453
00015e  6401              STR      r1,[r0,#0x40]         ;453
000160  f04f0120          MOV      r1,#0x20              ;456
000164  f04f30ff          MOV      r0,#0xffffffff        ;456
000168  f7fffffe          BL       output_MDIO
00016c  2104              MOVS     r1,#4                 ;459
00016e  2006              MOVS     r0,#6                 ;459
000170  f7fffffe          BL       output_MDIO
000174  2105              MOVS     r1,#5                 ;462
000176  2001              MOVS     r0,#1                 ;462
000178  f7fffffe          BL       output_MDIO
00017c  2105              MOVS     r1,#5                 ;465
00017e  4620              MOV      r0,r4                 ;465
000180  f7fffffe          BL       output_MDIO
000184  f7fffffe          BL       turnaround_MDIO
000188  f7fffffe          BL       input_MDIO
00018c  4604              MOV      r4,r0                 ;471
00018e  f7fffffe          BL       turnaround_MDIO
000192  e7de              B        |L1.338|
;;;491    
                          ENDP

                  write_PHY PROC
;;;398    
;;;399    static void write_PHY (U32 PhyReg, U16 Value) {
000194  b570              PUSH     {r4-r6,lr}
000196  4605              MOV      r5,r0
000198  460c              MOV      r4,r1
;;;400      /* Write a data 'Value' to PHY register 'PhyReg'. */
;;;401      U32 tout;
;;;402    
;;;403      if (dev_175x == __TRUE) {
00019a  48a0              LDR      r0,|L1.1052|
00019c  7800              LDRB     r0,[r0,#0]  ; dev_175x
00019e  2801              CMP      r0,#1
0001a0  d011              BEQ      |L1.454|
;;;404        /* Software MII Management for LPC175x. */
;;;405        /* Remapped MDC on P2.8 and MDIO on P2.9 do not work. */
;;;406        LPC_GPIO2->FIODIR |= MDIO;
;;;407    
;;;408        /* 32 consecutive ones on MDO to establish sync */
;;;409        output_MDIO (0xFFFFFFFF, 32);
;;;410    
;;;411        /* start code (01), write command (01) */
;;;412        output_MDIO (0x05, 4);
;;;413    
;;;414        /* write PHY address */
;;;415        output_MDIO (DP83848C_DEF_ADR >> 8, 5);
;;;416    
;;;417        /* write the PHY register to write */
;;;418        output_MDIO (PhyReg, 5);
;;;419    
;;;420        /* turnaround MDIO (1,0)*/
;;;421        output_MDIO (0x02, 2);
;;;422    
;;;423        /* write the data value */
;;;424        output_MDIO (Value, 16);
;;;425    
;;;426        /* turnaround MDO is tristated */
;;;427        turnaround_MDIO ();
;;;428      }
;;;429      else {
;;;430        /* Hardware MII Management for LPC176x devices. */
;;;431        LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
0001a2  f04f42a0          MOV      r2,#0x50000000
0001a6  f4457080          ORR      r0,r5,#0x100
0001aa  6290              STR      r0,[r2,#0x28]
;;;432        LPC_EMAC->MWTD = Value;
0001ac  62d4              STR      r4,[r2,#0x2c]
;;;433    
;;;434        /* Wait utill operation completed */
;;;435        for (tout = 0; tout < MII_WR_TOUT; tout++) {
0001ae  f04f0000          MOV      r0,#0
0001b2  f44f23a0          MOV      r3,#0x50000
                  |L1.438|
;;;436          if ((LPC_EMAC->MIND & MIND_BUSY) == 0) {
0001b6  6b51              LDR      r1,[r2,#0x34]
0001b8  07c9              LSLS     r1,r1,#31
0001ba  d003              BEQ      |L1.452|
0001bc  f1000001          ADD      r0,r0,#1              ;435
0001c0  4298              CMP      r0,r3                 ;435
0001c2  d3f8              BCC      |L1.438|
                  |L1.452|
;;;437            break;
;;;438          }
;;;439        }
;;;440      }
;;;441    }
0001c4  bd70              POP      {r4-r6,pc}
                  |L1.454|
0001c6  4894              LDR      r0,|L1.1048|
0001c8  6c01              LDR      r1,[r0,#0x40]         ;406
0001ca  f4417100          ORR      r1,r1,#0x200          ;406
0001ce  6401              STR      r1,[r0,#0x40]         ;406
0001d0  f04f0120          MOV      r1,#0x20              ;409
0001d4  f04f30ff          MOV      r0,#0xffffffff        ;409
0001d8  f7fffffe          BL       output_MDIO
0001dc  2104              MOVS     r1,#4                 ;412
0001de  2005              MOVS     r0,#5                 ;412
0001e0  f7fffffe          BL       output_MDIO
0001e4  2105              MOVS     r1,#5                 ;415
0001e6  2001              MOVS     r0,#1                 ;415
0001e8  f7fffffe          BL       output_MDIO
0001ec  2105              MOVS     r1,#5                 ;418
0001ee  4628              MOV      r0,r5                 ;418
0001f0  f7fffffe          BL       output_MDIO
0001f4  2102              MOVS     r1,#2                 ;421
0001f6  4608              MOV      r0,r1                 ;421
0001f8  f7fffffe          BL       output_MDIO
0001fc  2110              MOVS     r1,#0x10              ;424
0001fe  4620              MOV      r0,r4                 ;424
000200  f7fffffe          BL       output_MDIO
000204  e8bd4070          POP      {r4-r6,lr}            ;427
000208  e7fe              B        turnaround_MDIO
;;;442    
                          ENDP

                  init_ethernet PROC
;;;66     
;;;67     void init_ethernet (void) {
00020a  e92d41fc          PUSH     {r2-r8,lr}
;;;68       /* Initialize the EMAC ethernet controller. */
;;;69       U32 regv,tout,id1,id2;
;;;70       U32 pb[2];
;;;71     
;;;72       dev_175x = __FALSE;
00020e  4c83              LDR      r4,|L1.1052|
000210  f04f0600          MOV      r6,#0
000214  7026              STRB     r6,[r4,#0]
;;;73       /* Read device ID with IAP*/
;;;74       pb[0] = 54;
000216  f04f0036          MOV      r0,#0x36
00021a  9000              STR      r0,[sp,#0]
;;;75       iap_entry (&pb[0], &pb[0]);
00021c  6862              LDR      r2,[r4,#4]  ; iap_entry
00021e  4669              MOV      r1,sp
000220  4668              MOV      r0,sp
000222  4790              BLX      r2
;;;76       if ((pb[1] >> 24) == 0x25) {
000224  9801              LDR      r0,[sp,#4]
000226  2125              MOVS     r1,#0x25
000228  ebb16f10          CMP      r1,r0,LSR #24
00022c  d102              BNE      |L1.564|
;;;77         /* Use software RMII management routines. */
;;;78         dev_175x = __TRUE;
00022e  f04f0001          MOV      r0,#1
000232  7020              STRB     r0,[r4,#0]
                  |L1.564|
;;;79       }
;;;80     
;;;81       /* Power Up the EMAC controller. */
;;;82       LPC_SC->PCONP |= 0x40000000;
000234  487a              LDR      r0,|L1.1056|
000236  6801              LDR      r1,[r0,#0]
000238  f0414180          ORR      r1,r1,#0x40000000
00023c  6001              STR      r1,[r0,#0]
;;;83     
;;;84       /* Enable P1 Ethernet Pins. */
;;;85       LPC_PINCON->PINSEL2 = 0x50150105;
00023e  487a              LDR      r0,|L1.1064|
000240  4978              LDR      r1,|L1.1060|
000242  6081              STR      r1,[r0,#8]
;;;86       if (dev_175x == __FALSE) {
000244  7821              LDRB     r1,[r4,#0]  ; dev_175x
000246  2900              CMP      r1,#0
000248  d071              BEQ      |L1.814|
;;;87         /* LPC176x devices, no MDIO, MDC remap. */
;;;88         LPC_PINCON->PINSEL3 = (LPC_PINCON->PINSEL3 & ~0x0000000F) | 0x00000005;
;;;89       }
;;;90       else {
;;;91         /* LPC175x devices, use software MII management. */  
;;;92         LPC_PINCON->PINSEL4 &= ~0x000F0000;
00024a  6901              LDR      r1,[r0,#0x10]
00024c  f4212170          BIC      r1,r1,#0xf0000
000250  6101              STR      r1,[r0,#0x10]
;;;93         LPC_GPIO2->FIODIR |= MDC;
000252  4871              LDR      r0,|L1.1048|
000254  6c01              LDR      r1,[r0,#0x40]
000256  f4417180          ORR      r1,r1,#0x100
00025a  6401              STR      r1,[r0,#0x40]
                  |L1.604|
;;;94       }
;;;95     
;;;96       /* Reset all EMAC internal modules. */
;;;97       LPC_EMAC->MAC1    = MAC1_RES_TX | MAC1_RES_MCS_TX | MAC1_RES_RX | 
00025c  f04f45a0          MOV      r5,#0x50000000
000260  f44f404f          MOV      r0,#0xcf00
000264  6028              STR      r0,[r5,#0]
;;;98                           MAC1_RES_MCS_RX | MAC1_SIM_RES | MAC1_SOFT_RES;
;;;99       LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
000266  f04f0078          MOV      r0,#0x78
00026a  f8c50100          STR      r0,[r5,#0x100]
;;;100    
;;;101      /* A short delay after reset. */
;;;102      for (tout = 100; tout; tout--);
00026e  f04f0064          MOV      r0,#0x64
                  |L1.626|
000272  f1a00001          SUB      r0,r0,#1
000276  2800              CMP      r0,#0
000278  d1fb              BNE      |L1.626|
;;;103    
;;;104      /* Initialize MAC control registers. */
;;;105      LPC_EMAC->MAC1 = MAC1_PASS_ALL;
00027a  f04f0002          MOV      r0,#2
00027e  6028              STR      r0,[r5,#0]
;;;106      LPC_EMAC->MAC2 = MAC2_CRC_EN | MAC2_PAD_EN;
000280  f04f0030          MOV      r0,#0x30
000284  6068              STR      r0,[r5,#4]
;;;107      LPC_EMAC->MAXF = ETH_MAX_FLEN;
000286  f44f60c0          MOV      r0,#0x600
00028a  6168              STR      r0,[r5,#0x14]
;;;108      LPC_EMAC->CLRT = CLRT_DEF;
00028c  f243700f          MOV      r0,#0x370f
000290  6128              STR      r0,[r5,#0x10]
;;;109      LPC_EMAC->IPGR = IPGR_DEF;
000292  f04f0712          MOV      r7,#0x12
000296  60ef              STR      r7,[r5,#0xc]
;;;110    
;;;111      /* Enable Reduced MII interface. */
;;;112      LPC_EMAC->Command = CR_RMII | CR_PASS_RUNT_FRM;
000298  f44f7010          MOV      r0,#0x240
00029c  f8c50100          STR      r0,[r5,#0x100]
;;;113    
;;;114      /* Reset Reduced MII Logic. */
;;;115      LPC_EMAC->SUPP = SUPP_RES_RMII;
0002a0  f44f6000          MOV      r0,#0x800
0002a4  61a8              STR      r0,[r5,#0x18]
;;;116      for (tout = 100; tout; tout--);
0002a6  f04f0464          MOV      r4,#0x64
                  |L1.682|
0002aa  f1a40401          SUB      r4,r4,#1
0002ae  2c00              CMP      r4,#0
0002b0  d1fb              BNE      |L1.682|
;;;117      LPC_EMAC->SUPP = 0;
0002b2  61ae              STR      r6,[r5,#0x18]
;;;118    
;;;119      /* Put the DP83848C in reset mode */
;;;120      write_PHY (PHY_REG_BMCR, 0x8000);
0002b4  f44f4100          MOV      r1,#0x8000
0002b8  f04f0000          MOV      r0,#0
0002bc  f7fffffe          BL       write_PHY
;;;121    
;;;122      /* Wait for hardware reset to end. */
;;;123      for (tout = 0; tout < 0x100000; tout++) {
0002c0  f44f1880          MOV      r8,#0x100000
                  |L1.708|
;;;124        regv = read_PHY (PHY_REG_BMCR);
0002c4  2000              MOVS     r0,#0
0002c6  f7fffffe          BL       read_PHY
;;;125        if (!(regv & 0x8800)) {
0002ca  f4104f08          TST      r0,#0x8800
0002ce  d003              BEQ      |L1.728|
0002d0  f1040401          ADD      r4,r4,#1              ;123
0002d4  4544              CMP      r4,r8                 ;123
0002d6  d3f5              BCC      |L1.708|
                  |L1.728|
;;;126          /* Reset complete, device not Power Down. */
;;;127          break;
;;;128        }
;;;129      }
;;;130    
;;;131      /* Check if this is a DP83848C PHY. */
;;;132      id1 = read_PHY (PHY_REG_IDR1);
0002d8  2002              MOVS     r0,#2
0002da  f7fffffe          BL       read_PHY
0002de  4604              MOV      r4,r0
;;;133      id2 = read_PHY (PHY_REG_IDR2);
0002e0  f04f0003          MOV      r0,#3
0002e4  f7fffffe          BL       read_PHY
;;;134    
;;;135      if (((id1 << 16) | (id2 & 0xFFF0)) == DP83848C_ID) {
0002e8  f64f71f0          MOV      r1,#0xfff0
0002ec  4008              ANDS     r0,r0,r1
0002ee  494f              LDR      r1,|L1.1068|
0002f0  ea404004          ORR      r0,r0,r4,LSL #16
0002f4  4288              CMP      r0,r1
0002f6  d10f              BNE      |L1.792|
;;;136        /* Configure the PHY device */
;;;137    #if defined (_10MBIT_)
;;;138        /* Connect at 10MBit */
;;;139        write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);
;;;140    #elif defined (_100MBIT_)
;;;141        /* Connect at 100MBit */
;;;142        write_PHY (PHY_REG_BMCR, PHY_FULLD_100M);
;;;143    #else
;;;144        /* Use autonegotiation about the link speed. */
;;;145        write_PHY (PHY_REG_BMCR, PHY_AUTO_NEG);
0002f8  f44f5140          MOV      r1,#0x3000
0002fc  2000              MOVS     r0,#0
0002fe  f7fffffe          BL       write_PHY
;;;146        /* Wait to complete Auto_Negotiation. */
;;;147        for (tout = 0; tout < 0x100000; tout++) {
000302  f04f0400          MOV      r4,#0
                  |L1.774|
;;;148          regv = read_PHY (PHY_REG_BMSR);
000306  2001              MOVS     r0,#1
000308  f7fffffe          BL       read_PHY
;;;149          if (regv & 0x0020) {
00030c  0680              LSLS     r0,r0,#26
00030e  d403              BMI      |L1.792|
000310  f1040401          ADD      r4,r4,#1              ;147
000314  4544              CMP      r4,r8                 ;147
000316  d3f6              BCC      |L1.774|
                  |L1.792|
;;;150            /* Autonegotiation Complete. */
;;;151            break;
;;;152          }
;;;153        }
;;;154    #endif
;;;155      }
;;;156    
;;;157      /* Check the link status. */
;;;158      for (tout = 0; tout < 0x10000; tout++) {
000318  f04f0400          MOV      r4,#0
00031c  f44f3880          MOV      r8,#0x10000
                  |L1.800|
;;;159        regv = read_PHY (PHY_REG_STS);
000320  2010              MOVS     r0,#0x10
000322  f7fffffe          BL       read_PHY
;;;160        if (regv & 0x0001) {
000326  07c1              LSLS     r1,r0,#31
000328  d10c              BNE      |L1.836|
00032a  e007              B        |L1.828|
00032c  e7ff              B        |L1.814|
                  |L1.814|
00032e  68c1              LDR      r1,[r0,#0xc]          ;88
000330  f021010f          BIC      r1,r1,#0xf            ;88
000334  f1010105          ADD      r1,r1,#5              ;88
000338  60c1              STR      r1,[r0,#0xc]          ;88
00033a  e78f              B        |L1.604|
                  |L1.828|
00033c  f1040401          ADD      r4,r4,#1              ;158
000340  4544              CMP      r4,r8                 ;158
000342  d3ed              BCC      |L1.800|
                  |L1.836|
;;;161          /* Link is on. */
;;;162          break;
;;;163        }
;;;164      }
;;;165    
;;;166      /* Configure Full/Half Duplex mode. */
;;;167      if (regv & 0x0004) {
000344  0741              LSLS     r1,r0,#29
000346  d50d              BPL      |L1.868|
;;;168        /* Full duplex is enabled. */
;;;169        LPC_EMAC->MAC2    |= MAC2_FULL_DUP;
000348  6869              LDR      r1,[r5,#4]
00034a  f0410101          ORR      r1,r1,#1
00034e  6069              STR      r1,[r5,#4]
;;;170        LPC_EMAC->Command |= CR_FULL_DUP;
000350  f8d51100          LDR      r1,[r5,#0x100]
000354  f4416180          ORR      r1,r1,#0x400
000358  f8c51100          STR      r1,[r5,#0x100]
;;;171        LPC_EMAC->IPGT     = IPGT_FULL_DUP;
00035c  f04f0115          MOV      r1,#0x15
000360  60a9              STR      r1,[r5,#8]
000362  e000              B        |L1.870|
                  |L1.868|
;;;172      }
;;;173      else {
;;;174        /* Half duplex mode. */
;;;175        LPC_EMAC->IPGT = IPGT_HALF_DUP;
000364  60af              STR      r7,[r5,#8]
                  |L1.870|
;;;176      }
;;;177    
;;;178      /* Configure 100MBit/10MBit mode. */
;;;179      if (regv & 0x0002) {
000366  0780              LSLS     r0,r0,#30
000368  d501              BPL      |L1.878|
;;;180        /* 10MBit mode. */
;;;181        LPC_EMAC->SUPP = 0;
00036a  61ae              STR      r6,[r5,#0x18]
00036c  e002              B        |L1.884|
                  |L1.878|
;;;182      }
;;;183      else {
;;;184        /* 100MBit mode. */
;;;185        LPC_EMAC->SUPP = SUPP_SPEED;
00036e  f44f7080          MOV      r0,#0x100
000372  61a8              STR      r0,[r5,#0x18]
                  |L1.884|
;;;186      }
;;;187    
;;;188      /* Set the Ethernet MAC Address registers */
;;;189      LPC_EMAC->SA0 = ((U32)own_hw_adr[5] << 8) | (U32)own_hw_adr[4];
000374  482e              LDR      r0,|L1.1072|
000376  7901              LDRB     r1,[r0,#4]  ; own_hw_adr
000378  7942              LDRB     r2,[r0,#5]  ; own_hw_adr
00037a  ea412102          ORR      r1,r1,r2,LSL #8
00037e  6429              STR      r1,[r5,#0x40]
;;;190      LPC_EMAC->SA1 = ((U32)own_hw_adr[3] << 8) | (U32)own_hw_adr[2];
000380  7881              LDRB     r1,[r0,#2]  ; own_hw_adr
000382  78c2              LDRB     r2,[r0,#3]  ; own_hw_adr
000384  ea412102          ORR      r1,r1,r2,LSL #8
000388  6469              STR      r1,[r5,#0x44]
;;;191      LPC_EMAC->SA2 = ((U32)own_hw_adr[1] << 8) | (U32)own_hw_adr[0];
00038a  7801              LDRB     r1,[r0,#0]  ; own_hw_adr
00038c  7840              LDRB     r0,[r0,#1]  ; own_hw_adr
00038e  ea412000          ORR      r0,r1,r0,LSL #8
000392  64a8              STR      r0,[r5,#0x48]
;;;192    
;;;193      /* Initialize Tx and Rx DMA Descriptors */
;;;194      rx_descr_init ();
000394  f7fffffe          BL       rx_descr_init
;;;195      tx_descr_init ();
000398  f7fffffe          BL       tx_descr_init
;;;196    
;;;197      /* Receive Broadcast, Multicast and Perfect Match Packets */
;;;198      LPC_EMAC->RxFilterCtrl = RFC_MCAST_EN | RFC_BCAST_EN | RFC_PERFECT_EN;
00039c  f04f0026          MOV      r0,#0x26
0003a0  f8c50200          STR      r0,[r5,#0x200]
;;;199    
;;;200      /* Enable EMAC interrupts. */
;;;201      LPC_EMAC->IntEnable = INT_RX_DONE | INT_TX_DONE;
0003a4  f04f0088          MOV      r0,#0x88
0003a8  f8c50fe4          STR      r0,[r5,#0xfe4]
;;;202    
;;;203      /* Reset all interrupts */
;;;204      LPC_EMAC->IntClear  = 0xFFFF;
0003ac  f64f70ff          MOV      r0,#0xffff
0003b0  f8c50fe8          STR      r0,[r5,#0xfe8]
;;;205    
;;;206      /* Enable receive and transmit mode of MAC Ethernet core */
;;;207      LPC_EMAC->Command  |= (CR_RX_EN | CR_TX_EN);
0003b4  f8d50100          LDR      r0,[r5,#0x100]
0003b8  f0400003          ORR      r0,r0,#3
0003bc  f8c50100          STR      r0,[r5,#0x100]
;;;208      LPC_EMAC->MAC1     |= MAC1_REC_EN;
0003c0  6828              LDR      r0,[r5,#0]
0003c2  f0400001          ORR      r0,r0,#1
0003c6  6028              STR      r0,[r5,#0]
;;;209    
;;;210    }
0003c8  e8bd81fc          POP      {r2-r8,pc}
;;;211    
                          ENDP

                  int_enable_eth PROC
;;;214    
;;;215    void int_enable_eth (void) {
0003cc  4819              LDR      r0,|L1.1076|
0003ce  f04f5180          MOV      r1,#0x10000000
0003d2  6001              STR      r1,[r0,#0]
;;;216      /* Ethernet Interrupt Enable function. */
;;;217      NVIC_EnableIRQ(ENET_IRQn);
;;;218    }
0003d4  4770              BX       lr
;;;219    
                          ENDP

                  int_disable_eth PROC
;;;222    
;;;223    void int_disable_eth (void) {
0003d6  4818              LDR      r0,|L1.1080|
0003d8  f04f5180          MOV      r1,#0x10000000
0003dc  6001              STR      r1,[r0,#0]
;;;224      /* Ethernet Interrupt Disable function. */
;;;225      NVIC_DisableIRQ(ENET_IRQn);
;;;226    }
0003de  4770              BX       lr
;;;227    
                          ENDP

                  send_frame PROC
;;;230    
;;;231    void send_frame (OS_FRAME *frame) {
0003e0  b5f0              PUSH     {r4-r7,lr}
;;;232      /* Send frame to EMAC ethernet controller */
;;;233      U32 idx,len;
;;;234      U32 *sp,*dp;
;;;235    
;;;236      idx = LPC_EMAC->TxProduceIndex;
0003e2  f04f45a0          MOV      r5,#0x50000000
0003e6  f8d54128          LDR      r4,[r5,#0x128]
;;;237      sp  = (U32 *)&frame->data[0];
0003ea  f1000204          ADD      r2,r0,#4
;;;238      dp  = (U32 *)Tx_Desc[idx].Packet;
0003ee  4e06              LDR      r6,|L1.1032|
0003f0  f8563034          LDR      r3,[r6,r4,LSL #3]
;;;239    
;;;240      /* Copy frame data to EMAC packet buffers. */
;;;241      for (len = (frame->length + 3) >> 2; len; len--) {
0003f4  8801              LDRH     r1,[r0,#0]
0003f6  f1010103          ADD      r1,r1,#3
0003fa  ea4f0191          LSR      r1,r1,#2
0003fe  b311              CBZ      r1,|L1.1094|
                  |L1.1024|
;;;242        *dp++ = *sp++;
000400  ca80              LDM      r2!,{r7}
000402  e01b              B        |L1.1084|
                  |L1.1028|
                          DCD      ||.bss||+0x1864
                  |L1.1032|
                          DCD      ||.bss||+0x40
                  |L1.1036|
                          DCD      0x5000011c
                  |L1.1040|
                          DCD      0x800005ff
                  |L1.1044|
                          DCD      0x50000108
                  |L1.1048|
                          DCD      0x2009c000
                  |L1.1052|
                          DCD      ||.data||
                  |L1.1056|
                          DCD      0x400fc0c4
                  |L1.1060|
                          DCD      0x50150105
                  |L1.1064|
                          DCD      0x4002c000
                  |L1.1068|
                          DCD      0x20005c90
                  |L1.1072|
                          DCD      own_hw_adr
                  |L1.1076|
                          DCD      0xe000e100
                  |L1.1080|
                          DCD      0xe000e180
                  |L1.1084|
00043c  c380              STM      r3!,{r7}
00043e  f1a10101          SUB      r1,r1,#1              ;241
000442  2900              CMP      r1,#0                 ;241
000444  d1dc              BNE      |L1.1024|
                  |L1.1094|
;;;243      }
;;;244      Tx_Desc[idx].Ctrl = (frame->length-1) | (TCTRL_INT | TCTRL_LAST);
000446  8800              LDRH     r0,[r0,#0]
000448  eb0601c4          ADD      r1,r6,r4,LSL #3
00044c  f1a00001          SUB      r0,r0,#1
000450  f0404040          ORR      r0,r0,#0xc0000000
000454  6048              STR      r0,[r1,#4]
;;;245    
;;;246      /* Start frame transmission. */
;;;247      if (++idx == NUM_TX_FRAG) idx = 0;
000456  f1040401          ADD      r4,r4,#1
00045a  2c03              CMP      r4,#3
00045c  d101              BNE      |L1.1122|
00045e  f04f0400          MOV      r4,#0
                  |L1.1122|
;;;248      LPC_EMAC->TxProduceIndex = idx;
000462  f8c54128          STR      r4,[r5,#0x128]
;;;249    }
000466  bdf0              POP      {r4-r7,pc}
;;;250    
                          ENDP

                  ENET_IRQHandler PROC
;;;253    
;;;254    void ENET_IRQHandler (void) {
000468  b570              PUSH     {r4-r6,lr}
;;;255      /* EMAC Ethernet Controller Interrupt function. */
;;;256      OS_FRAME *frame;
;;;257      U32 idx,int_stat,RxLen,info;
;;;258      U32 *sp,*dp;
;;;259    
;;;260      while ((int_stat = (LPC_EMAC->IntStatus & LPC_EMAC->IntEnable)) != 0) {
;;;261        LPC_EMAC->IntClear = int_stat;
00046a  f04f46a0          MOV      r6,#0x50000000
00046e  e03a              B        |L1.1254|
                  |L1.1136|
000470  f8c60fe8          STR      r0,[r6,#0xfe8]
;;;262        if (int_stat & INT_RX_DONE) {
000474  0700              LSLS     r0,r0,#28
000476  d536              BPL      |L1.1254|
;;;263          /* Packet received, check if packet is valid. */
;;;264          idx = LPC_EMAC->RxConsumeIndex;
000478  f8d64118          LDR      r4,[r6,#0x118]
;;;265          while (idx != LPC_EMAC->RxProduceIndex) {
00047c  e02f              B        |L1.1246|
                  |L1.1150|
;;;266            info = Rx_Stat[idx].Info;
00047e  481d              LDR      r0,|L1.1268|
000480  f8500034          LDR      r0,[r0,r4,LSL #3]
;;;267            if (!(info & RINFO_LAST_FLAG)) {
000484  0041              LSLS     r1,r0,#1
000486  d523              BPL      |L1.1232|
;;;268              goto rel;
;;;269            }
;;;270    
;;;271            RxLen = (info & RINFO_SIZE) - 3;
000488  f3c0050a          UBFX     r5,r0,#0,#11
00048c  f1a50503          SUB      r5,r5,#3
;;;272            if (RxLen > ETH_MTU || (info & RINFO_ERR_MASK)) {
000490  f24051ea          MOV      r1,#0x5ea
000494  428d              CMP      r5,r1
000496  d81b              BHI      |L1.1232|
000498  4917              LDR      r1,|L1.1272|
00049a  4208              TST      r0,r1
00049c  d118              BNE      |L1.1232|
;;;273              /* Invalid frame, ignore it and free buffer. */
;;;274              goto rel;
;;;275            }
;;;276            /* Flag 0x80000000 to skip sys_error() call when out of memory. */
;;;277            frame = alloc_mem (RxLen | 0x80000000);
00049e  f0454000          ORR      r0,r5,#0x80000000
0004a2  f7fffffe          BL       alloc_mem
;;;278            /* if 'alloc_mem()' has failed, ignore this packet. */
;;;279            if (frame != NULL) {
0004a6  b198              CBZ      r0,|L1.1232|
;;;280              dp = (U32 *)&frame->data[0];
0004a8  f1000204          ADD      r2,r0,#4
;;;281              sp = (U32 *)Rx_Desc[idx].Packet;
0004ac  4911              LDR      r1,|L1.1268|
0004ae  f1a10120          SUB      r1,r1,#0x20
0004b2  f8513034          LDR      r3,[r1,r4,LSL #3]
;;;282              for (RxLen = (RxLen + 3) >> 2; RxLen; RxLen--) {
0004b6  f1050503          ADD      r5,r5,#3
0004ba  ea4f0195          LSR      r1,r5,#2
0004be  b129              CBZ      r1,|L1.1228|
                  |L1.1216|
;;;283                *dp++ = *sp++;
0004c0  cb20              LDM      r3!,{r5}
0004c2  c220              STM      r2!,{r5}
0004c4  f1a10101          SUB      r1,r1,#1              ;282
0004c8  2900              CMP      r1,#0                 ;282
0004ca  d1f9              BNE      |L1.1216|
                  |L1.1228|
;;;284              }
;;;285              put_in_queue (frame);
0004cc  f7fffffe          BL       put_in_queue
                  |L1.1232|
;;;286            }
;;;287    rel:    if (++idx == NUM_RX_FRAG) idx = 0;
0004d0  1c64              ADDS     r4,r4,#1
0004d2  2c04              CMP      r4,#4
0004d4  d101              BNE      |L1.1242|
0004d6  f04f0400          MOV      r4,#0
                  |L1.1242|
;;;288            /* Release frame from EMAC buffer. */
;;;289            LPC_EMAC->RxConsumeIndex = idx;
0004da  f8c64118          STR      r4,[r6,#0x118]
                  |L1.1246|
0004de  f8d60114          LDR      r0,[r6,#0x114]        ;265
0004e2  42a0              CMP      r0,r4                 ;265
0004e4  d1cb              BNE      |L1.1150|
                  |L1.1254|
0004e6  f8d60fe0          LDR      r0,[r6,#0xfe0]        ;260
0004ea  f8d61fe4          LDR      r1,[r6,#0xfe4]        ;260
0004ee  4008              ANDS     r0,r0,r1              ;260
0004f0  d1be              BNE      |L1.1136|
;;;290          }
;;;291        }
;;;292        if (int_stat & INT_TX_DONE) {
;;;293          /* Frame transmit completed. */
;;;294        }
;;;295      }
;;;296    
;;;297    }
0004f2  bd70              POP      {r4-r6,pc}
;;;298    
                          ENDP

                  |L1.1268|
                          DCD      ||.bss||+0x20
                  |L1.1272|
                          DCD      0x1b900000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  Rx_Desc
                          %        32
                  Rx_Stat
                          %        32
                  Tx_Desc
                          %        24
                  Tx_Stat
                          %        12
                  rx_buf
                          %        6144
                  tx_buf
                          %        4608

                          AREA ||.data||, DATA, ALIGN=2

                  dev_175x
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  iap_entry
                          DCD      0x1fff1ff1

;*** Start embedded assembler ***

#line 1 "C:\\Keil\\ARM\\Boards\\Keil\\MCB1700\\RL\\TCPnet\\Library\\EMAC_LPC17xx.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_EMAC_LPC17xx_c_f63b8310____REV16|
#line 112 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_EMAC_LPC17xx_c_f63b8310____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_EMAC_LPC17xx_c_f63b8310____REVSH|
#line 130
|__asm___14_EMAC_LPC17xx_c_f63b8310____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
