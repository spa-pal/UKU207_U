; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\EXE\timer.o --depend=.\EXE\timer.d --feedback=.\EXE\UKU_220_IPS_TERMOKOMPENSAT.fed --cpu=Cortex-M3 --apcs=interwork -O1 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\NXP\LPC17xx -D__MICROLIB -DUKU_220_IPS_TERMOKOMPENSAT -DUKU2071x --omf_browse=.\EXE\timer.crf Timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  delayMs PROC
;;;1095    */
;;;1096   static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  b570              PUSH     {r4-r6,lr}
;;;1097   {
;;;1098     NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
000002  f2423427          MOV      r4,#0x2327
000006  4361              MULS     r1,r4,r1
000008  2300              MOVS     r3,#0
00000a  2202              MOVS     r2,#2
00000c  24ff              MOVS     r4,#0xff
00000e  2504              MOVS     r5,#4
000010  2601              MOVS     r6,#1
000012  b958              CBNZ     r0,|L1.44|
000014  f04f2040          MOV      r0,#0x40004000
;;;1099   }
000018  6042              STR      r2,[r0,#4]
00001a  60c3              STR      r3,[r0,#0xc]
00001c  6181              STR      r1,[r0,#0x18]
00001e  6004              STR      r4,[r0,#0]
000020  6145              STR      r5,[r0,#0x14]
000022  6046              STR      r6,[r0,#4]
                  |L1.36|
000024  6841              LDR      r1,[r0,#4]
000026  07c9              LSLS     r1,r1,#31
000028  d1fc              BNE      |L1.36|
                  |L1.42|
00002a  bd70              POP      {r4-r6,pc}
                  |L1.44|
00002c  2801              CMP      r0,#1
00002e  d1fc              BNE      |L1.42|
000030  4805              LDR      r0,|L1.72|
000032  6042              STR      r2,[r0,#4]
000034  60c3              STR      r3,[r0,#0xc]
000036  6181              STR      r1,[r0,#0x18]
000038  6004              STR      r4,[r0,#0]
00003a  6145              STR      r5,[r0,#0x14]
00003c  6046              STR      r6,[r0,#4]
                  |L1.62|
00003e  6841              LDR      r1,[r0,#4]
000040  07c9              LSLS     r1,r1,#31
000042  d1fc              BNE      |L1.62|
000044  bd70              POP      {r4-r6,pc}
;;;1100   
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      0x40008000

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.2||, ||.text||
                  TIMER0_IRQHandler PROC
;;;1095    */
;;;1096   static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2001              MOVS     r0,#1
;;;1097   {
;;;1098     NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
000002  f04f2140          MOV      r1,#0x40004000
000006  6008              STR      r0,[r1,#0]
000008  480c              LDR      r0,|L2.60|
00000a  6801              LDR      r1,[r0,#0]  ; timer0_counter
00000c  1c49              ADDS     r1,r1,#1
00000e  6001              STR      r1,[r0,#0]  ; timer0_counter
000010  490b              LDR      r1,|L2.64|
000012  2000              MOVS     r0,#0
000014  7008              STRB     r0,[r1,#0]
;;;1099   }
000016  480b              LDR      r0,|L2.68|
000018  6801              LDR      r1,[r0,#0]
00001a  f02101ff          BIC      r1,r1,#0xff
00001e  1d09              ADDS     r1,r1,#4
000020  6001              STR      r1,[r0,#0]
000022  6801              LDR      r1,[r0,#0]
000024  f0417180          ORR      r1,r1,#0x1000000
000028  6001              STR      r1,[r0,#0]
00002a  4770              BX       lr
;;;1100   
                          ENDP

                  TIMER1_IRQHandler PROC
;;;31     *****************************************************************************/
;;;32     void delayMs(uint8_t timer_num, uint32_t delayInMs)
;;;33     {
;;;34       if ( timer_num == 0 )
;;;35       {
;;;36     	LPC_TIM0->TCR = 0x02;		/* reset timer */
;;;37     	LPC_TIM0->PR  = 0x00;		/* set prescaler to zero */
;;;38     	LPC_TIM0->MR0 = delayInMs * (9000000 / 1000-1);
;;;39     	LPC_TIM0->IR  = 0xff;		/* reset all interrrupts */
;;;40     	LPC_TIM0->MCR = 0x04;		/* stop timer on match */
;;;41     	LPC_TIM0->TCR = 0x01;		/* start timer */
;;;42       
;;;43     	/* wait until delay time has elapsed */
;;;44     	while (LPC_TIM0->TCR & 0x01);
;;;45       }
;;;46       else if ( timer_num == 1 )
00002c  4906              LDR      r1,|L2.72|
00002e  2001              MOVS     r0,#1
;;;47       {
;;;48     	LPC_TIM1->TCR = 0x02;		/* reset timer */
000030  6008              STR      r0,[r1,#0]
000032  4802              LDR      r0,|L2.60|
;;;49     	LPC_TIM1->PR  = 0x00;		/* set prescaler to zero */
000034  6841              LDR      r1,[r0,#4]  ; timer1_counter
;;;50     	LPC_TIM1->MR0 = delayInMs * (9000000 / 1000-1);
000036  1c49              ADDS     r1,r1,#1
;;;51     	LPC_TIM1->IR  = 0xff;		/* reset all interrrupts */
000038  6041              STR      r1,[r0,#4]  ; timer1_counter
;;;52     	LPC_TIM1->MCR = 0x04;		/* stop timer on match */
00003a  4770              BX       lr
;;;53     	LPC_TIM1->TCR = 0x01;		/* start timer */
;;;54       
;;;55     	/* wait until delay time has elapsed */
;;;56     	while (LPC_TIM1->TCR & 0x01);
;;;57       }
;;;58       return;
;;;59     }
;;;60     
                          ENDP

                  |L2.60|
                          DCD      ||.data||
                  |L2.64|
                          DCD      adc_self_ch_cnt
                  |L2.68|
                          DCD      0x40034000
                  |L2.72|
                          DCD      0x40008000

                          AREA ||area_number.3||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.3||, ||.text||
                  enable_timer PROC
;;;31     *****************************************************************************/
;;;32     void delayMs(uint8_t timer_num, uint32_t delayInMs)
000000  2101              MOVS     r1,#1
;;;33     {
;;;34       if ( timer_num == 0 )
;;;35       {
;;;36     	LPC_TIM0->TCR = 0x02;		/* reset timer */
;;;37     	LPC_TIM0->PR  = 0x00;		/* set prescaler to zero */
;;;38     	LPC_TIM0->MR0 = delayInMs * (9000000 / 1000-1);
000002  b918              CBNZ     r0,|L3.12|
000004  f04f2040          MOV      r0,#0x40004000
000008  6041              STR      r1,[r0,#4]            ;33
00000a  4770              BX       lr                    ;36
                  |L3.12|
;;;39     	LPC_TIM0->IR  = 0xff;		/* reset all interrrupts */
00000c  4801              LDR      r0,|L3.20|
;;;40     	LPC_TIM0->MCR = 0x04;		/* stop timer on match */
00000e  6041              STR      r1,[r0,#4]
;;;41     	LPC_TIM0->TCR = 0x01;		/* start timer */
000010  4770              BX       lr
;;;42       
;;;43     	/* wait until delay time has elapsed */
;;;44     	while (LPC_TIM0->TCR & 0x01);
;;;45       }
;;;46       else if ( timer_num == 1 )
;;;47       {
;;;48     	LPC_TIM1->TCR = 0x02;		/* reset timer */
;;;49     	LPC_TIM1->PR  = 0x00;		/* set prescaler to zero */
;;;50     	LPC_TIM1->MR0 = delayInMs * (9000000 / 1000-1);
;;;51     	LPC_TIM1->IR  = 0xff;		/* reset all interrrupts */
;;;52     	LPC_TIM1->MCR = 0x04;		/* stop timer on match */
;;;53     	LPC_TIM1->TCR = 0x01;		/* start timer */
;;;54       
;;;55     	/* wait until delay time has elapsed */
;;;56     	while (LPC_TIM1->TCR & 0x01);
;;;57       }
;;;58       return;
;;;59     }
;;;60     
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40008000

                          AREA ||area_number.4||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.text||
                  disable_timer PROC
;;;31     *****************************************************************************/
;;;32     void delayMs(uint8_t timer_num, uint32_t delayInMs)
000000  2100              MOVS     r1,#0
;;;33     {
;;;34       if ( timer_num == 0 )
;;;35       {
;;;36     	LPC_TIM0->TCR = 0x02;		/* reset timer */
;;;37     	LPC_TIM0->PR  = 0x00;		/* set prescaler to zero */
;;;38     	LPC_TIM0->MR0 = delayInMs * (9000000 / 1000-1);
000002  b918              CBNZ     r0,|L4.12|
000004  f04f2040          MOV      r0,#0x40004000
000008  6041              STR      r1,[r0,#4]            ;33
00000a  4770              BX       lr                    ;36
                  |L4.12|
;;;39     	LPC_TIM0->IR  = 0xff;		/* reset all interrrupts */
00000c  4801              LDR      r0,|L4.20|
;;;40     	LPC_TIM0->MCR = 0x04;		/* stop timer on match */
00000e  6041              STR      r1,[r0,#4]
;;;41     	LPC_TIM0->TCR = 0x01;		/* start timer */
000010  4770              BX       lr
;;;42       
;;;43     	/* wait until delay time has elapsed */
;;;44     	while (LPC_TIM0->TCR & 0x01);
;;;45       }
;;;46       else if ( timer_num == 1 )
;;;47       {
;;;48     	LPC_TIM1->TCR = 0x02;		/* reset timer */
;;;49     	LPC_TIM1->PR  = 0x00;		/* set prescaler to zero */
;;;50     	LPC_TIM1->MR0 = delayInMs * (9000000 / 1000-1);
;;;51     	LPC_TIM1->IR  = 0xff;		/* reset all interrrupts */
;;;52     	LPC_TIM1->MCR = 0x04;		/* stop timer on match */
;;;53     	LPC_TIM1->TCR = 0x01;		/* start timer */
;;;54       
;;;55     	/* wait until delay time has elapsed */
;;;56     	while (LPC_TIM1->TCR & 0x01);
;;;57       }
;;;58       return;
;;;59     }
;;;60     
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40008000

                          AREA ||area_number.5||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.text||
                  reset_timer PROC
;;;31     *****************************************************************************/
;;;32     void delayMs(uint8_t timer_num, uint32_t delayInMs)
000000  b930              CBNZ     r0,|L5.16|
;;;33     {
;;;34       if ( timer_num == 0 )
;;;35       {
;;;36     	LPC_TIM0->TCR = 0x02;		/* reset timer */
;;;37     	LPC_TIM0->PR  = 0x00;		/* set prescaler to zero */
;;;38     	LPC_TIM0->MR0 = delayInMs * (9000000 / 1000-1);
000002  f04f2140          MOV      r1,#0x40004000
000006  6848              LDR      r0,[r1,#4]
000008  f0400002          ORR      r0,r0,#2              ;33
;;;39     	LPC_TIM0->IR  = 0xff;		/* reset all interrrupts */
00000c  6048              STR      r0,[r1,#4]
;;;40     	LPC_TIM0->MCR = 0x04;		/* stop timer on match */
00000e  4770              BX       lr
                  |L5.16|
;;;41     	LPC_TIM0->TCR = 0x01;		/* start timer */
000010  4902              LDR      r1,|L5.28|
000012  6848              LDR      r0,[r1,#4]            ;34
000014  f0400002          ORR      r0,r0,#2              ;36
000018  6048              STR      r0,[r1,#4]            ;36
00001a  4770              BX       lr                    ;37
;;;42       
;;;43     	/* wait until delay time has elapsed */
;;;44     	while (LPC_TIM0->TCR & 0x01);
;;;45       }
;;;46       else if ( timer_num == 1 )
;;;47       {
;;;48     	LPC_TIM1->TCR = 0x02;		/* reset timer */
;;;49     	LPC_TIM1->PR  = 0x00;		/* set prescaler to zero */
;;;50     	LPC_TIM1->MR0 = delayInMs * (9000000 / 1000-1);
;;;51     	LPC_TIM1->IR  = 0xff;		/* reset all interrrupts */
;;;52     	LPC_TIM1->MCR = 0x04;		/* stop timer on match */
;;;53     	LPC_TIM1->TCR = 0x01;		/* start timer */
;;;54       
;;;55     	/* wait until delay time has elapsed */
;;;56     	while (LPC_TIM1->TCR & 0x01);
;;;57       }
;;;58       return;
;;;59     }
;;;60     
                          ENDP

                  |L5.28|
                          DCD      0x40008000

                          AREA ||area_number.6||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.text||
                  init_timer PROC
;;;31     *****************************************************************************/
;;;32     void delayMs(uint8_t timer_num, uint32_t delayInMs)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34       if ( timer_num == 0 )
;;;35       {
;;;36     	LPC_TIM0->TCR = 0x02;		/* reset timer */
;;;37     	LPC_TIM0->PR  = 0x00;		/* set prescaler to zero */
;;;38     	LPC_TIM0->MR0 = delayInMs * (9000000 / 1000-1);
000002  2200              MOVS     r2,#0
000004  4b0c              LDR      r3,|L6.56|
000006  2403              MOVS     r4,#3
000008  b948              CBNZ     r0,|L6.30|
00000a  601a              STR      r2,[r3,#0]            ;36  ; timer0_counter
;;;39     	LPC_TIM0->IR  = 0xff;		/* reset all interrrupts */
00000c  f04f2040          MOV      r0,#0x40004000
;;;40     	LPC_TIM0->MCR = 0x04;		/* stop timer on match */
;;;41     	LPC_TIM0->TCR = 0x01;		/* start timer */
000010  6181              STR      r1,[r0,#0x18]
000012  6144              STR      r4,[r0,#0x14]         ;34
000014  2001              MOVS     r0,#1                 ;36
000016  f7fffffe          BL       NVIC_EnableIRQ
00001a  2001              MOVS     r0,#1                 ;37
00001c  bd10              POP      {r4,pc}               ;38
                  |L6.30|
00001e  2801              CMP      r0,#1                 ;39
000020  d108              BNE      |L6.52|
000022  605a              STR      r2,[r3,#4]  ; timer1_counter
;;;42       
;;;43     	/* wait until delay time has elapsed */
;;;44     	while (LPC_TIM0->TCR & 0x01);
000024  4805              LDR      r0,|L6.60|
000026  6181              STR      r1,[r0,#0x18]
000028  6144              STR      r4,[r0,#0x14]
;;;45       }
;;;46       else if ( timer_num == 1 )
;;;47       {
;;;48     	LPC_TIM1->TCR = 0x02;		/* reset timer */
;;;49     	LPC_TIM1->PR  = 0x00;		/* set prescaler to zero */
;;;50     	LPC_TIM1->MR0 = delayInMs * (9000000 / 1000-1);
;;;51     	LPC_TIM1->IR  = 0xff;		/* reset all interrrupts */
;;;52     	LPC_TIM1->MCR = 0x04;		/* stop timer on match */
;;;53     	LPC_TIM1->TCR = 0x01;		/* start timer */
;;;54       
;;;55     	/* wait until delay time has elapsed */
;;;56     	while (LPC_TIM1->TCR & 0x01);
;;;57       }
;;;58       return;
;;;59     }
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       NVIC_EnableIRQ
000030  2001              MOVS     r0,#1                 ;48
000032  bd10              POP      {r4,pc}               ;48
                  |L6.52|
000034  2000              MOVS     r0,#0                 ;49
000036  bd10              POP      {r4,pc}               ;50
;;;60     
                          ENDP

                  |L6.56|
                          DCD      ||.data||
                  |L6.60|
                          DCD      0x40008000

                          AREA ||area_number.7||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.7||, ||.text||
                  NVIC_EnableIRQ PROC
;;;31     *****************************************************************************/
;;;32     void delayMs(uint8_t timer_num, uint32_t delayInMs)
000000  f000021f          AND      r2,r0,#0x1f
;;;33     {
;;;34       if ( timer_num == 0 )
;;;35       {
;;;36     	LPC_TIM0->TCR = 0x02;		/* reset timer */
;;;37     	LPC_TIM0->PR  = 0x00;		/* set prescaler to zero */
;;;38     	LPC_TIM0->MR0 = delayInMs * (9000000 / 1000-1);
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5              ;33
00000a  f04f22e0          MOV      r2,#0xe000e000        ;36
;;;39     	LPC_TIM0->IR  = 0xff;		/* reset all interrrupts */
;;;40     	LPC_TIM0->MCR = 0x04;		/* stop timer on match */
00000e  eb020080          ADD      r0,r2,r0,LSL #2
000012  f8c01100          STR      r1,[r0,#0x100]        ;34
000016  4770              BX       lr                    ;36
;;;41     	LPC_TIM0->TCR = 0x01;		/* start timer */
;;;42       
;;;43     	/* wait until delay time has elapsed */
;;;44     	while (LPC_TIM0->TCR & 0x01);
;;;45       }
;;;46       else if ( timer_num == 1 )
;;;47       {
;;;48     	LPC_TIM1->TCR = 0x02;		/* reset timer */
;;;49     	LPC_TIM1->PR  = 0x00;		/* set prescaler to zero */
;;;50     	LPC_TIM1->MR0 = delayInMs * (9000000 / 1000-1);
;;;51     	LPC_TIM1->IR  = 0xff;		/* reset all interrrupts */
;;;52     	LPC_TIM1->MCR = 0x04;		/* stop timer on match */
;;;53     	LPC_TIM1->TCR = 0x01;		/* start timer */
;;;54       
;;;55     	/* wait until delay time has elapsed */
;;;56     	while (LPC_TIM1->TCR & 0x01);
;;;57       }
;;;58       return;
;;;59     }
;;;60     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  timer0_counter
                          DCD      0x00000000
                  timer1_counter
                          DCD      0x00000000
